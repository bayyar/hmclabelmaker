<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meal Label Generator</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Karla:wght@300;400;500;600;700;800&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --color-orange: #A15408;
            --color-gray: #BDC7C3;
            --color-red: #520212;
            --color-blue: #003854;
            --color-green: #444E20;
        }
        
        body {
            font-family: 'Karla', sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }
        
        .app-container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .app-header {
            background: white;
            padding: 20px 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .app-header h1 {
            color: #333;
            font-weight: 700;
            font-size: 28px;
            margin: 0;
        }
        
        .header-actions {
            display: flex;
            gap: 10px;
        }
        
        .main-layout {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
        }
        
        .preview-section {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 600px;
        }
        
        .label-navigation {
            display: none; /* Hide from preview section - moved to controls */
        }
        
        /* On-screen actual-size preview helpers */
        .scale-wrapper {
            transform-origin: top left;
        }
        
        .preview-scale-controls {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }
        
        .preview-scale-row {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }
        
        .calibration-box {
            width: 1in;
            height: 1in;
            border: 2px dashed #9ca3af;
            background: repeating-linear-gradient(90deg, transparent, transparent 0.25in, rgba(37,99,235,0.08) 0.25in, rgba(37,99,235,0.08) 0.26in),
                        repeating-linear-gradient(0deg, transparent, transparent 0.25in, rgba(37,99,235,0.08) 0.25in, rgba(37,99,235,0.08) 0.26in);
        }
        
        .scale-slider {
            flex: 1 1 200px;
        }
        
        .scale-percent-input {
            width: 80px;
        }
        
        .preview-section h2 {
            margin-bottom: 20px;
            color: #333;
            font-weight: 700;
            font-size: 20px;
            align-self: flex-start;
        }
        
        .controls-section {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            height: fit-content;
        }
        
        .controls-section h3 {
            margin-bottom: 20px;
            color: #333;
            font-weight: 700;
            font-size: 18px;
        }
        
        /* Elegant navigation controls */
        .label-navigation {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 25px;
            padding: 20px 0;
            background: transparent; /* Remove background shading */
            border-radius: 0;
            border: none;
        }
        
        .label-counter {
            text-align: center;
            font-weight: 600;
            color: #334155;
            font-size: 16px;
            margin-bottom: 5px;
        }
        
        .nav-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        .nav-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            min-width: 80px;
        }
        
        .nav-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        
        .nav-button:active {
            transform: translateY(0);
        }
        
        .nav-button:disabled {
            background: #cbd5e1;
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .nav-button:disabled:hover {
            transform: none;
        }
        
        .form-group {
            display: flex;
            flex-direction: column;
            margin-bottom: 18px;
        }
        
        label {
            font-weight: 600;
            margin-bottom: 5px;
            color: #555;
            font-size: 13px;
        }
        
        input, textarea, select {
            padding: 12px 10px; /* Match button height */
            border: 1px solid #ddd;
            border-radius: 5px;
            font-family: inherit;
            font-size: 14px;
            width: 100%;
            height: 44px; /* Match button height */
            box-sizing: border-box;
        }
        
        textarea {
            resize: vertical;
            min-height: 70px;
            height: auto; /* Override fixed height for textarea */
        }
        
        .rotation-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            min-height: 44px;
        }
        
        .rotation-btn {
            background: #f3f4f6;
            color: #374151;
            border: 1px solid #d1d5db;
            padding: 10px 20px;
            border-radius: 999px;
            font-weight: 500;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
            white-space: nowrap;
            height: 44px;
            display: inline-flex;
            align-items: center;
            box-sizing: border-box;
            width: auto;
            min-width: auto;
        }
        
        .rotation-btn:hover {
            background: #e5e7eb;
            border-color: #9ca3af;
        }
        
        .rotation-btn.active {
            background: #2563eb;
            color: white;
            border-color: #2563eb;
        }
        
        .rotation-btn.active:hover {
            background: #1d4ed8;
            border-color: #1d4ed8;
        }
        
        .rotation-btn:disabled {
            background: #f9fafb;
            color: #d1d5db;
            cursor: not-allowed;
            border-color: #e5e7eb;
        }
        
        .button-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 24px;
        }
        
        button {
            background: #2563eb;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 5px;
            font-weight: 600;
            cursor: pointer;
            font-size: 15px;
            width: 100%;
            height: 44px; /* Match input height */
            box-sizing: border-box;
            transition: background-color 0.2s ease;
        }
        
        button:hover {
            background: #1d4ed8;
        }
        
        button.secondary {
            background: #6b7280;
        }
        
        button.secondary:hover {
            background: #4b5563;
        }
        
        button:disabled {
            background: #cbd5e1;
            cursor: not-allowed;
        }
        
        button:disabled:hover {
            background: #cbd5e1;
        }
        
        /* Mobile responsive layout */
        @media (max-width: 968px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
            
            .preview-section {
                order: 1;
            }
            
            .controls-section {
                order: 2;
            }
        }
        
        /* Label Styles - 3x4 Grid System */
        .label {
            width: 100%;
            max-width: 600px;
            height: auto;
            aspect-ratio: 4/3;
            background: white;
            padding: 0;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 30% 30% 40%;
            grid-template-rows: 0.6fr 2.4fr; /* Top row 20%, bottom area 80% */
            gap: 0;
            position: relative;
            font-family: 'Karla', sans-serif;
            box-sizing: border-box;
            /* No border for preview - clean appearance */
            border: none;
            box-shadow: none;
            outline: none;
            z-index: 10;
        }
        
        .loading-indicator {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 600px;
            height: auto;
            aspect-ratio: 4/3;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin: 0 auto;
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #2563eb;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-text {
            color: #666;
            font-size: 16px;
            font-weight: 500;
        }
        
        /* Bleed area - extends beyond trim for professional printing */
        .label::before {
            content: '';
            position: absolute;
            top: -0.125in; /* 1/8" bleed */
            left: -0.125in;
            right: -0.125in;
            bottom: -0.125in;
            background: white;
            z-index: -2;
            border-radius: 0;
            /* Dotted border for bleed area */
            border: 1px dotted #000;
            /* Ensure this doesn't cover the main border */
            pointer-events: none;
        }
        
        /* Bleed area background for top row - extends brand color to bleed edges */
        .label::after {
            content: '';
            position: absolute;
            top: -0.125in;
            left: -0.125in;
            right: -0.125in;
            height: calc(20% + 0.125in); /* Top row height + bleed */
            background: var(--brand-bg, var(--color-green));
            z-index: -1;
            pointer-events: none;
        }
        
        /* Grid lines overlay */
        .grid-guides {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            display: none;
            z-index: 5;
            /* Light red grid lines */
            background-image:
                /* Vertical lines */
                linear-gradient(to right, rgba(255,0,0,0.3) 0%, rgba(255,0,0,0.3) 1px, transparent 1px),
                linear-gradient(to right, rgba(255,0,0,0.3) 0%, rgba(255,0,0,0.3) 1px, transparent 1px),
                /* Horizontal line at 20% */
                linear-gradient(to bottom, rgba(255,0,0,0.3) 0%, rgba(255,0,0,0.3) 1px, transparent 1px);
            background-repeat: no-repeat;
            background-size: 100% 100%, 100% 100%, 100% 100%;
            background-position: 30% 0, 60% 0, 0 20%;
        }
        .label.show-grid .grid-guides { display: block; }
        
        /* Crop marks at corners of 3x4 border */
        .crop-marks {
            position: absolute;
            top: -0.125in;
            left: -0.125in;
            right: -0.125in;
            bottom: -0.125in;
            pointer-events: none;
            z-index: 10;
            display: none;
        }
        
        .crop-marks::before {
            content: '';
            position: absolute;
            /* Top-left crop mark */
            top: 0;
            left: 0;
            width: 0.125in;
            height: 0.125in;
            border-top: 2px solid #000;
            border-left: 2px solid #000;
        }
        
        .crop-marks::after {
            content: '';
            position: absolute;
            /* Top-right crop mark */
            top: 0;
            right: 0;
            width: 0.125in;
            height: 0.125in;
            border-top: 2px solid #000;
            border-right: 2px solid #000;
        }
        
        .crop-marks .bottom-left {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 0.125in;
            height: 0.125in;
            border-bottom: 2px solid #000;
            border-left: 2px solid #000;
        }
        
        .crop-marks .bottom-right {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 0.125in;
            height: 0.125in;
            border-bottom: 2px solid #000;
            border-right: 2px solid #000;
        }
        
        .label.show-grid .crop-marks { display: block; }

        /* Comprehensive grid guide overlay */
        .grid-guides {
            position: absolute;
            /* align guides with the content area (inside padding) */
            top: 0.15in; left: 0.15in; right: 0.15in; bottom: 0.15in;
            pointer-events: none;
            display: none;
            /* All column and row dividers */
            background-image:
                /* Column dividers at 30% and 60% */
                linear-gradient(to right, rgba(255,0,0,0.3) 0%, rgba(255,0,0,0.3) 1px, transparent 1px),
                linear-gradient(to right, rgba(255,0,0,0.3) 0%, rgba(255,0,0,0.3) 1px, transparent 1px),
                /* Row dividers at ~33% and 66% of remaining rows */
                linear-gradient(to bottom, rgba(255,0,0,0.3) 0%, rgba(255,0,0,0.3) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(255,0,0,0.3) 0%, rgba(255,0,0,0.3) 1px, transparent 1px);
            background-repeat: no-repeat;
            background-size: 100% 100%, 100% 100%, 100% 100%, 100% 100%;
            background-position: 30% 0, 60% 0, 0 calc(0.6fr / (0.6fr + 1.2fr + 1.2fr) * 100%), 0 calc((0.6fr + 1.2fr) / (0.6fr + 1.2fr + 1.2fr) * 100%);
            /* Outer border */
            outline: 1px solid rgba(255,0,0,0.3);
        }
        .label.show-grid .grid-guides { display: block; }

        
        /* Cell 1 - Logo (spans all columns in row 1) */
        .cell-1 {
            grid-column: 1 / 4;
            grid-row: 1;
            display: flex;
            align-items: stretch;
            justify-content: flex-start;
            padding: 8px;
            background: transparent;
            gap: 10px;
            min-height: 0;
            position: relative;
            z-index: 1;
        }
        .cell-1::before {
            content: '';
            position: absolute;
            /* Extend background to bleed area edges */
            top: -0.125in;
            left: -0.125in;
            right: -0.125in;
            bottom: 0;
            background: var(--brand-bg, var(--color-green));
            z-index: -1;
        }
        .cell-1 > * { position: relative; z-index: 2; }
        
        .logo-container {
            height: 100%;
            display: flex;
            align-items: stretch;
        }
        
        .logo-container img {
            height: 100%;
            width: auto;
            object-fit: contain;
            display: block;
            transform: scale(1.2); /* Increase logo size by 20% */
        }
        
        /* Cell 2 - Empty/Company Info */
        .cell-2 { display: none; }
        
        /* Cell 3 - Best By and Weight */
        .cell-3 { display: none; }
        
        .cell-3 .date-item {
            margin-bottom: 4px;
        }
        
        .cell-3 .label-text {
            font-weight: 700;
            font-size: 0.875em; /* 7pt equivalent for screen, maintains 7pt minimum for print */
        }
        
        .cell-3 .date-value {
            font-size: 0.875em; /* 7pt equivalent for screen, maintains 7pt minimum for print */
            font-weight: 400;
        }
        
        .cell-3 .weight-text {
            font-weight: 400;
            margin-top: 2px;
            font-size: 0.875em; /* 7pt equivalent for screen, maintains 7pt minimum for print */
        }
        
        .cell-3 .weight-label {
            font-weight: 700;
        }
        
        /* Title next to logo in row 1 */
        .brand-title {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            color: #fff;
            flex: 1 1 auto;
            overflow: hidden;
            text-align: left; /* left align the title text */
            padding: 0; /* Remove padding to align with top of logo */
        }

        .brand-title h4 {
            font-size: 28pt; /* JavaScript will override for scaling */
            font-weight: 800;
            line-height: normal; /* Allow space for descenders (g, j, p, q, y) */
            color: inherit;
            white-space: nowrap;
            overflow: hidden;
            margin-top: -2px; /* Align top with logo */
            /* Removed text-overflow: ellipsis to allow text scaling */
        }

        .brand-title .dish-subtitle {
            font-size: 20pt; /* JavaScript will override for scaling */
            font-weight: 400;
            font-style: italic;
            line-height: normal; /* Allow space for descenders */
            color: inherit;
            white-space: nowrap;
            overflow: hidden;
            /* Removed text-overflow: ellipsis to allow text scaling */
        }
        
        /* Cells 6, 9 - Ingredients and Info (merged) */
        .cell-6-9 {
            grid-column: 3;
            grid-row: 2;
            display: flex;
            flex-direction: column;
            line-height: 1.3;
            padding: 12px;
            background: transparent; /* Remove gray background */
            overflow: hidden;
            font-size: 0.875em; /* Ensure consistent base font size */
            border: none; /* Remove border */
            border-radius: 0; /* Remove border radius */
            margin: 0; /* Remove margin for proper alignment */
            border-left: 2px solid #ddd; /* Add vertical line separator */
            margin-left: 8px; /* Add some space from the separator */
        }
        
        .cell-6-9 .ingredients-label {
            font-weight: 700;
            margin-bottom: 4px; /* Consistent spacing */
        }
        
        .ingredients-list {
            color: #333;
            margin-bottom: 8px; /* Consistent spacing */
            line-height: 1.3;
            font-weight: 400;
        }
        
        .allergens-section {
            padding-top: 6px;
            border-top: 1px solid #ddd;
            border-bottom: 1px solid #ddd;
            padding-bottom: 8px; /* Increased padding-bottom to match margin-top for better spacing */
        }
        
        .allergens-label {
            font-weight: 700;
        }

        .subsection-label {
            font-weight: 700;
        }

        .meta-text {
            color: #333;
            font-weight: 400;
        }
        
        .meta-block {
            padding: 8px 0; /* 8px vertical padding for the entire meta block */
        }
        
        .meta-row {
            padding: 2px 0; /* 2px vertical padding for Best By and Net Weight */
        }
        
        .allergens-text {
            color: #333;
            font-weight: 400;
        }
        
        .company-info {
            padding-top: 8px;
            padding-bottom: 4px;
            border-top: 1px solid #ddd;
            color: #444;
            font-weight: 400;
            font-size: 0.85em; /* Slightly smaller than instructions/ingredients */
        }
        
        .company-name {
            font-weight: 600;
            margin-bottom: 2px;
            font-size: 0.85em; /* Slightly smaller than instructions/ingredients */
        }
        
        /* Cells 7-8 - Heating Instructions */
        .cell-7-8 {
            grid-column: 1 / 3;
            grid-row: 2;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            padding: 12px 8px 8px 8px; /* Match top padding with right column */
            font-size: 0.875em; /* Match font size with right column */
        }
        
        .chef-instructions, .fast-instructions {
            display: flex;
            flex-direction: column;
        }
        
        .instructions-title {
            font-weight: 700;
            margin-bottom: 4px;
        }
        
        .instructions-text {
            line-height: 1.4;
            color: #333;
            font-weight: 400;
        }
        
        .instructions-text ol {
            padding-left: 14px;
            margin: 0;
        }
        
        .instructions-text li {
            margin-bottom: 2px;
        }
        
        /* Print styles */
        @media print {
            body {
                background: white;
                padding: 0;
            }
            
            .app-header, .controls-section, .preview-section h2 {
                display: none !important;
            }
            
            .main-layout {
                display: block;
            }
            
            .preview-section {
                box-shadow: none;
                padding: 0;
            }
            
            .label {
                border: none !important; /* Remove black border for printing */
                page-break-after: always;
                width: 4.5in !important; /* Include bleed in print */
                height: 3.5in !important;
            }
            
            /* Preserve JavaScript-applied font sizes for print/PDF */
            .brand-title h4 {
                font-size: inherit !important; /* Use JavaScript-applied size */
            }
            
            .brand-title .dish-subtitle {
                font-size: inherit !important; /* Use JavaScript-applied size */
            }
            
            /* Fallback sizes if JavaScript doesn't apply */
            .brand-title h4:not([style*="font-size"]) {
                font-size: 28pt !important;
            }
            
            .brand-title .dish-subtitle:not([style*="font-size"]) {
                font-size: 20pt !important;
            }
            
            .cell-3 .label-text,
            .cell-3 .date-value,
            .cell-3 .weight-text {
                font-size: 7pt !important;
            }
            
            .cell-6-9 {
                font-size: 7pt !important; /* All child elements inherit this font size */
            }
            
            .company-info,
            .company-name {
                font-size: 6pt !important;
            }
            
            .cell-7-8 {
                font-size: 7pt !important; /* All child elements inherit this font size */
            }
            
            /* Ensure on-screen transforms do not affect print */
            .scale-wrapper {
                transform: none !important;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="app-header">
            <h1>Hudson Meal Co. Label Generator</h1>
            <div class="header-actions">
                <button class="nav-button" onclick="window.open('https://docs.google.com/spreadsheets/d/1UugIwrAyHXOAgBrQcU9zFwIEOYg9-baJdoGCWSMIJNk/edit?gid=0#gid=0', '_blank')">Edit CSV</button>
            </div>
        </div>
        
        <div class="main-layout">
            <div class="preview-section">
                <div class="scale-wrapper" id="scaleWrapper">
                    <!-- Loading indicator -->
                    <div class="loading-indicator" id="loadingIndicator">
                        <div class="loading-spinner"></div>
                        <div class="loading-text">Loading label data...</div>
                    </div>
                    
                    <!-- Label preview (hidden initially) -->
                    <div class="label" id="labelPreview" style="display: none;">
                    <div class="grid-guides" aria-hidden="true"></div>
                    <div class="crop-marks" aria-hidden="true">
                        <div class="bottom-left"></div>
                        <div class="bottom-right"></div>
                    </div>
                    <!-- Cell 1: Logo + Title (spans all columns) -->
                    <div class="cell-1">
                        <div class="logo-container">
                            <img id="brandLogo" src="images/logos/White Logo Suite/HMC_Vertical Full Lockup_White [RGB].png" alt="Hudson Meal Co Logo" />
                        </div>
                        <div class="brand-title">
                            <h4 id="previewDish">Select Season and Rotation</h4>
                            <div class="dish-subtitle" id="previewSubtitle">to load labels</div>
                        </div>
                    </div>
                    
                    <!-- Cell 2: Empty/Available -->
                    <div class="cell-2">
                        <!-- Empty for now -->
                    </div>
                    
                    <!-- Cell 3 removed; Best By/Weight moved under allergens -->
                    
                    <!-- Cells 4-5: removed (content moved to row 1) -->
                    
                    <!-- Cells 6 & 9: Ingredients & Info -->
                    <div class="cell-6-9">
                        <div class="ingredients-label">Ingredients:</div>
                        <div class="ingredients-list" id="previewIngredients">Please select a season and rotation to load dish data</div>
                        <div class="allergens-section">
                            <span class="allergens-label">Allergens:</span>
                            <span class="allergens-text" id="previewAllergens">-</span>
                        </div>
                        <div class="meta-block">
                            <div class="meta-row">
                                <span class="subsection-label">Best By:</span>
                                <span class="meta-text" id="previewBestBy">-</span>
                            </div>
                            <div class="meta-row">
                                <span class="subsection-label">Net Weight:</span>
                                <span class="meta-text" id="previewWeight">-</span>
                            </div>
                        </div>
                        <div class="company-info">
                            <div class="company-name">Hudson Meal Co. LLC</div>
                            <div>hudsonmealco.com</div>
                            <div style="margin-top: 4px;">86 Broad Street</div>
                            <div>Kinderhook, NY 12106</div>
                        </div>
                    </div>
                    
                    <!-- Cells 7-8: Heating Instructions -->
                    <div class="cell-7-8">
                        <div class="chef-instructions">
                            <div class="instructions-title">Chef Instructions:</div>
                            <div class="instructions-text" id="previewChefInstructions">
                                <ol>
                                    <li>Please select a season and rotation</li>
                                </ol>
                            </div>
                        </div>
                        <div class="fast-instructions">
                            <div class="instructions-title">Fast Instructions:</div>
                            <div class="instructions-text" id="previewFastInstructions">
                                <ol>
                                    <li>Please select a season and rotation</li>
                                </ol>
                            </div>
                        </div>
                    </div>
                    </div>
                </div>
            </div>
            
            <div class="controls-section">
                <h3>Label Selection</h3>
                <div class="form-group">
                    <label for="seasonSelect">Season</label>
                    <select id="seasonSelect">
                        <option value="">Select Season</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="rotationSelect">Rotation</label>
                    <div class="rotation-buttons" id="rotationButtons">
                        <!-- Buttons will be populated dynamically -->
                    </div>
                </div>
                <div class="form-group">
                    <label for="bestBy">Best By Date</label>
                    <input type="date" id="bestBy" />
                    <div id="shorterExpNote" style="display:none; font-size: 12px; color: #6b7280; margin-top: 4px;"></div>
                </div>
                
                <!-- Horizontal separator -->
                <div style="border-top: 1px solid #e2e8f0; margin: 20px 0;"></div>
                
                <!-- Elegant Navigation Controls -->
                <div class="label-navigation">
                    <div class="label-counter" id="labelCounter">Label 1 of 1</div>
                    <div class="nav-buttons">
                        <button class="nav-button" id="prevLabel" onclick="previousLabel()">← Previous</button>
                        <button class="nav-button" id="nextLabel" onclick="nextLabel()">Next →</button>
                    </div>
                </div>
                
                <!-- Horizontal separator -->
                <div style="border-top: 1px solid #e2e8f0; margin: 20px 0;"></div>
                
                <div class="button-group">
                    <button onclick="generatePDF()" id="downloadSingleBtn" disabled>Download Current PDF</button>
                    <button onclick="downloadAllPDFs()" id="downloadAllBtn" disabled class="secondary">Download All PDFs</button>
                </div>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        // Global variables for dish data and current state
        let allDishes = [];
        let filteredDishes = [];
        let currentLabelIndex = 0;
        
        /*
         * PDF-PREVIEW SYNCHRONIZATION SYSTEM
         * 
         * This system ensures that PDFs and previews are always visually identical (1:1 match).
         * 
         * CRITICAL: Any changes to font sizing MUST go through FontSyncManager.applyFontSizes()
         * to maintain synchronization. Direct style.fontSize changes will break sync.
         * 
         * How it works:
         * 1. FontSyncManager tracks all applied font sizes
         * 2. PDF generation uses the same sizes as preview
         * 3. VisualValidator confirms sync before PDF generation
         * 4. Future-proof safeguards prevent sync breaks
         * 
         * To maintain sync in future iterations:
         * - Always use FontSyncManager.applyFontSizes() for font changes
         * - Never directly modify style.fontSize on title/subtitle elements
         * - Test PDF generation after any font-related changes
         * - Check console for sync validation warnings
         */
        const FontSyncManager = {
            appliedSizes: {
                title: null,
                subtitle: null
            },
            
            // Apply font sizes consistently
            applyFontSizes(titleSize, subtitleSize) {
                const titleEl = document.getElementById('previewDish');
                const subtitleEl = document.getElementById('previewSubtitle');
                
                if (titleEl && subtitleEl) {
                    // Force override any CSS constraints
                    titleEl.style.fontSize = titleSize + 'pt !important';
                    subtitleEl.style.fontSize = subtitleSize + 'pt !important';
                    
                    // Also set without !important for compatibility
                    titleEl.style.setProperty('font-size', titleSize + 'pt', 'important');
                    subtitleEl.style.setProperty('font-size', subtitleSize + 'pt', 'important');
                    
                    // Store for PDF generation
                    this.appliedSizes.title = titleSize;
                    this.appliedSizes.subtitle = subtitleSize;
                    
                    // Add data attributes for debugging
                    titleEl.setAttribute('data-sync-title-size', titleSize + 'pt');
                    subtitleEl.setAttribute('data-sync-subtitle-size', subtitleSize + 'pt');
                    
                }
            },
            
            // Ensure PDF uses same sizes as preview
            ensurePDFSync() {
                return new Promise((resolve) => {
                    // Force reflow to ensure sizes are applied
                    requestAnimationFrame(() => {
                        const titleEl = document.getElementById('previewDish');
                        const subtitleEl = document.getElementById('previewSubtitle');
                        
                        if (titleEl && subtitleEl && this.appliedSizes.title && this.appliedSizes.subtitle) {
                            // Re-apply the exact same sizes
                            titleEl.style.fontSize = this.appliedSizes.title + 'pt';
                            subtitleEl.style.fontSize = this.appliedSizes.subtitle + 'pt';
                            
                            // Wait for browser to process the changes
                            setTimeout(resolve, 150);
                        } else {
                            resolve();
                        }
                    });
                });
            },
            
            // Validate that sizes are consistent
            validateSync() {
                const titleEl = document.getElementById('previewDish');
                const subtitleEl = document.getElementById('previewSubtitle');
                
                if (!titleEl || !subtitleEl) return false;
                
                const currentTitleSize = parseFloat(titleEl.style.fontSize);
                const currentSubtitleSize = parseFloat(subtitleEl.style.fontSize);
                
                const isSynced = (
                    this.appliedSizes.title === currentTitleSize &&
                    this.appliedSizes.subtitle === currentSubtitleSize
                );
                
                if (!isSynced) {
                }
                
                return isSynced;
            }
        };
        
        // Google Sheets configuration
        const SHEET_ID = '1UugIwrAyHXOAgBrQcU9zFwIEOYg9-baJdoGCWSMIJNk';
        const SHEET_GID = '0'; // Default sheet (first tab)
        const CSV_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${SHEET_GID}`;
        
        // Fetch dishes from Google Sheets
        async function fetchDishesFromSheet() {
            try {
                const response = await fetch(CSV_URL);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const csvText = await response.text();
                
                // Check if we got HTML instead of CSV (redirect page)
                if (csvText.includes('<HTML>') || csvText.includes('<html>')) {
                    throw new Error('Sheet is not publicly accessible. Please ensure the sheet is published to the web.');
                }
                
                allDishes = parseCSV(csvText);
                populateSeasonDropdown();
            } catch (error) {
                alert('Error loading dish data from Google Sheets. Please check your internet connection and ensure the sheet is published to the web.');
                
                // Load sample data for testing
                loadSampleData();
            }
        }
        
        // Load sample data for testing when Google Sheets is not accessible
        function loadSampleData() {
            allDishes = [
                {
                    'Season': 'Fall 2024',
                    'Rotation': 'Week 1',
                    'Dish Name': 'Braised Beef',
                    'Dish Subtitle': 'with Chimichurri Sauce',
                    'Net Weight': '1 lb',
                    'Ingredients': 'Grimaldi Farm grassfed organic beef, cilantro, parsley, organic extra-virgin olive oil, salt, red wine vinegar, black pepper, garlic, cumin',
                    'Allergens': 'None',
                    'Chef Instructions': '1. Preheat oven to 350°F\n2. Remove sleeve and film\n3. Remove sauce and trim\n4. Heat up 10-15 mins or until heated thoroughly\n5. Pour sauce on top',
                    'Fast Instructions': '1. Remove sleeve and peel corner of film to vent\n2. Remove sauce container\n3. Microwave for 2-4 mins or until heated thoroughly\n4. Pour sauce on top\n5. Remove film',
                    'Color': 'Green'
                },
                {
                    'Season': 'Fall 2024',
                    'Rotation': 'Week 1',
                    'Dish Name': 'Chicken Marsala',
                    'Dish Subtitle': 'with Wild Mushrooms',
                    'Net Weight': '1.5 lbs',
                    'Ingredients': 'Free-range chicken breast, marsala wine, wild mushrooms, shallots, garlic, butter, olive oil, salt, pepper',
                    'Allergens': 'None',
                    'Chef Instructions': '1. Preheat oven to 375°F\n2. Remove packaging\n3. Place in oven-safe dish\n4. Bake 20-25 minutes\n5. Let rest 5 minutes',
                    'Fast Instructions': '1. Remove packaging\n2. Microwave on high 3-4 minutes\n3. Let stand 2 minutes\n4. Stir and serve',
                    'Color': 'Orange'
                },
                {
                    'Season': 'Fall 2024',
                    'Rotation': 'Week 2',
                    'Dish Name': 'Salmon Teriyaki',
                    'Dish Subtitle': 'with Jasmine Rice',
                    'Net Weight': '1.25 lbs',
                    'Ingredients': 'Wild-caught salmon, teriyaki sauce, jasmine rice, sesame oil, ginger, garlic, soy sauce',
                    'Allergens': 'Fish, Soy',
                    'Chef Instructions': '1. Preheat oven to 400°F\n2. Remove packaging\n3. Place salmon on baking sheet\n4. Bake 12-15 minutes\n5. Serve over rice',
                    'Fast Instructions': '1. Remove packaging\n2. Microwave on high 3-4 minutes\n3. Let stand 2 minutes\n4. Serve',
                    'Color': 'Blue'
                },
                {
                    'Season': 'Fall 2024',
                    'Rotation': 'Staple',
                    'Dish Name': 'Caesar Salad',
                    'Dish Subtitle': 'Classic Caesar',
                    'Net Weight': '0.75 lbs',
                    'Ingredients': 'Romaine lettuce, parmesan cheese, croutons, caesar dressing, anchovies, lemon juice',
                    'Allergens': 'Dairy, Fish, Gluten',
                    'Chef Instructions': '1. Keep refrigerated\n2. Toss with dressing before serving\n3. Add croutons and parmesan\n4. Serve immediately',
                    'Fast Instructions': '1. Keep refrigerated\n2. Toss with dressing before serving\n3. Add croutons and parmesan\n4. Serve immediately',
                    'Color': 'Green'
                }
            ];
            populateSeasonDropdown();
        }
        
        // Parse CSV text into dish objects
        function parseCSV(csvText) {
            // First, we need to properly handle CSV with newlines inside quoted fields
            // Split by lines but be careful about quoted fields that span multiple lines
            const lines = [];
            let currentLine = '';
            let inQuotes = false;
            
            for (let i = 0; i < csvText.length; i++) {
                const char = csvText[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === '\n' && !inQuotes) {
                    if (currentLine.trim()) {
                        lines.push(currentLine.trim());
                    }
                    currentLine = '';
                    continue;
                }
                
                currentLine += char;
            }
            
            // Add the last line if it exists
            if (currentLine.trim()) {
                lines.push(currentLine.trim());
            }
            
            
            if (lines.length < 2) return [];
            
            // Parse CSV with proper handling of quoted fields
            const parseCSVLine = (line) => {
                const result = [];
                let current = '';
                let inQuotes = false;
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        result.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                result.push(current.trim());
                return result;
            };
            
            const headers = parseCSVLine(lines[0]).map(h => h.replace(/^"/, '').replace(/"$/, ''));
            
            const dishes = [];
            
            for (let i = 1; i < lines.length; i++) {
                const values = parseCSVLine(lines[i]).map(v => v.replace(/^"/, '').replace(/"$/, ''));
                
                if (values.length >= headers.length) {
                    const dish = {};
                    headers.forEach((header, index) => {
                        dish[header] = values[index] || '';
                    });
                    dishes.push(dish);
                } else {
                }
            }
            
            return dishes;
        }
        
        // Populate season dropdown with unique seasons
        function populateSeasonDropdown() {
            const seasonSelect = document.getElementById('seasonSelect');
            const seasons = [...new Set(allDishes.map(dish => dish.Season).filter(Boolean))];
            
            seasonSelect.innerHTML = '<option value="">Select Season</option>';
            seasons.forEach(season => {
                const option = document.createElement('option');
                option.value = season;
                option.textContent = season;
                seasonSelect.appendChild(option);
            });
        }
        
        // Populate rotation buttons based on selected season
        function populateRotationDropdown(season) {
            const rotationButtons = document.getElementById('rotationButtons');
            
            // Get all rotations
            const allRotations = [...new Set(allDishes
                .filter(dish => dish.Season === season)
                .map(dish => dish.Rotation)
                .filter(Boolean))];
            
            // Filter out 'Staple' from the list that we'll loop through (to avoid adding it twice)
            const rotations = allRotations
                .filter(rot => rot !== 'Staple')
                .sort((a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' }));
            
            // Check if staples exist for this season
            const hasStaples = allRotations.includes('Staple');
            
            rotationButtons.innerHTML = '';
            
            // Add staple button first if staples exist for this season
            if (hasStaples) {
                const stapleBtn = document.createElement('button');
                stapleBtn.className = 'rotation-btn';
                stapleBtn.textContent = 'Staple';
                stapleBtn.dataset.rotation = 'Staple';
                stapleBtn.onclick = () => selectRotation('Staple', stapleBtn);
                rotationButtons.appendChild(stapleBtn);
            }
            
            // Add regular rotation buttons (Staple already filtered out)
            rotations.forEach(rotation => {
                const btn = document.createElement('button');
                btn.className = 'rotation-btn';
                btn.textContent = rotation;
                btn.dataset.rotation = rotation;
                btn.onclick = () => selectRotation(rotation, btn);
                rotationButtons.appendChild(btn);
            });
        }
        
        // Select rotation and load labels
        function selectRotation(rotation, button) {
            // Remove active class from all buttons
            document.querySelectorAll('.rotation-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Add active class to clicked button
            button.classList.add('active');
            button.dataset.rotation = rotation;
            
            // Load labels
            const season = document.getElementById('seasonSelect').value;
            if (season && rotation) {
                loadLabelsWithRotation(rotation);
            }
        }
        
        // Load labels with specified rotation
        function loadLabelsWithRotation(rotation) {
            const season = document.getElementById('seasonSelect').value;
            
            filteredDishes = filterDishesBySeasonRotation(season, rotation);
            
            if (filteredDishes.length === 0) {
                alert('No dishes found for the selected Season and Rotation');
                return;
            }
            
            currentLabelIndex = 0;
            updateLabelDisplay();
            updateNavigationButtons();
            document.getElementById('downloadAllBtn').disabled = false;
            document.getElementById('downloadSingleBtn').disabled = false;
            
            // Show label and hide loading indicator
            showLabel();
        }
        
        // Filter dishes by season and rotation
        function filterDishesBySeasonRotation(season, rotation) {
            return allDishes.filter(dish => {
                // Include dishes that match the exact season and rotation only
                return dish.Season === season && dish.Rotation === rotation;
            });
        }
        
        // Load labels for selected season and rotation
        function loadLabels() {
            const season = document.getElementById('seasonSelect').value;
            const activeBtn = document.querySelector('.rotation-btn.active');
            const rotation = activeBtn ? activeBtn.dataset.rotation || activeBtn.textContent : null;
            
            if (!season || !rotation) {
                alert('Please select both Season and Rotation');
                return;
            }
            
            filteredDishes = filterDishesBySeasonRotation(season, rotation);
            
            if (filteredDishes.length === 0) {
                alert('No dishes found for the selected Season and Rotation');
                return;
            }
            
            currentLabelIndex = 0;
            updateLabelDisplay();
            updateNavigationButtons();
            document.getElementById('downloadAllBtn').disabled = false;
            document.getElementById('downloadSingleBtn').disabled = false;
            
            // Show label and hide loading indicator
            showLabel();
        }
        
        // Show label and hide loading indicator
        function showLabel() {
            document.getElementById('loadingIndicator').style.display = 'none';
            document.getElementById('labelPreview').style.display = 'grid';
        }
        
        // Show loading indicator and hide label
        function showLoading() {
            document.getElementById('loadingIndicator').style.display = 'flex';
            document.getElementById('labelPreview').style.display = 'none';
        }
        
        // Update label display with current dish data
        function updateLabelDisplay() {
            if (filteredDishes.length === 0) return;
            
            const dish = filteredDishes[currentLabelIndex];
            const bestByInput = document.getElementById('bestBy');
            // Determine if dish uses shorter expiration; label will show two days prior if so
            const shorterExpRaw = (dish['Shorter Expiration'] || '').toString().trim();
            const isShorter = shorterExpRaw === 'Yes';
            const bestByDate = bestByInput.value;
            
            // Update shorter-expiration note under the date picker
            const noteEl = document.getElementById('shorterExpNote');
            if (noteEl) {
                if (isShorter && bestByDate) {
                    const [y, m, d] = bestByDate.split('-').map(Number);
                    const sel = new Date(y, (m || 1) - 1, d || 1);
                    const prior = new Date(sel.getFullYear(), sel.getMonth(), sel.getDate() - 2);
                    const yyyy = prior.getFullYear();
                    const mm = String(prior.getMonth() + 1).padStart(2, '0');
                    const dd = String(prior.getDate()).padStart(2, '0');
                    noteEl.textContent = `Shorter expiration in effect: label shows ${formatDateWithDay(`${yyyy}-${mm}-${dd}`)}`;
                    noteEl.style.display = 'block';
                } else {
                    noteEl.style.display = 'none';
                    noteEl.textContent = '';
                }
            }
            
            
            // Update preview elements
            document.getElementById('previewDish').textContent = dish['Dish Name'] || 'Unknown Dish';
            document.getElementById('previewSubtitle').textContent = dish['Dish Subtitle'] || '';
            document.getElementById('previewWeight').textContent = dish['Net Wt'] || dish['Net Weight'] || '-';
            // Compute date shown on the label: default to picker's date; if shorter, show two days earlier
            let labelDateString = bestByDate;
            if (isShorter && bestByDate) {
                const [y2, m2, d2] = bestByDate.split('-').map(Number);
                const base = new Date(y2, (m2 || 1) - 1, d2 || 1);
                const prior2 = new Date(base.getFullYear(), base.getMonth(), base.getDate() - 2);
                const yyyy2 = prior2.getFullYear();
                const mm2 = String(prior2.getMonth() + 1).padStart(2, '0');
                const dd2 = String(prior2.getDate()).padStart(2, '0');
                labelDateString = `${yyyy2}-${mm2}-${dd2}`;
            }
            document.getElementById('previewBestBy').textContent = formatDateWithDay(labelDateString);
            document.getElementById('previewIngredients').textContent = dish.Ingredients || '-';
            document.getElementById('previewAllergens').textContent = dish.Allergens || 'None';
            document.getElementById('previewChefInstructions').innerHTML = formatInstructions(dish['Chef Instructions'] || '-');
            document.getElementById('previewFastInstructions').innerHTML = formatInstructions(dish['Fast Instructions'] || '-');
            
            // Update brand color from CSV Color column
            if (dish.Color) {
                const colorMapping = {
                    'Green': 'green',
                    'Red': 'red', 
                    'Blue': 'blue',
                    'Orange': 'orange',
                    'Gray': 'gray'
                };
                const mappedColor = colorMapping[dish.Color] || 'green';
                // Color selector removed, using default green branding
            }
            
            applyBranding();
            fitTitleToRow();
            updateLabelCounter();
        }
        
        // Update label counter display
        function updateLabelCounter() {
            const counter = document.getElementById('labelCounter');
            counter.textContent = `Label ${currentLabelIndex + 1} of ${filteredDishes.length}`;
        }
        
        // Navigation functions
        function previousLabel() {
            if (currentLabelIndex > 0) {
                currentLabelIndex--;
                updateLabelDisplay();
                updateNavigationButtons();
            }
        }
        
        function nextLabel() {
            if (currentLabelIndex < filteredDishes.length - 1) {
                currentLabelIndex++;
                updateLabelDisplay();
                updateNavigationButtons();
            }
        }
        
        // Update navigation button states
        function updateNavigationButtons() {
            document.getElementById('prevLabel').disabled = currentLabelIndex === 0;
            document.getElementById('nextLabel').disabled = currentLabelIndex === filteredDishes.length - 1;
        }
        
        // Calculate Best By Date (local date math, avoiding timezone shifts)
        function calculateBestByDate(daysAfterFriday = 5) {
            const today = new Date();
            const dayOfWeek = today.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
            
            // Find next Friday
            let daysUntilFriday;
            if (dayOfWeek <= 5) { // Sunday (0) to Friday (5)
                daysUntilFriday = 5 - dayOfWeek;
            } else { // Saturday (6)
                daysUntilFriday = 6; // Next Friday is 6 days away
            }
            
            const nextFriday = new Date(today.getFullYear(), today.getMonth(), today.getDate() + daysUntilFriday);
            const bestByDate = new Date(nextFriday.getFullYear(), nextFriday.getMonth(), nextFriday.getDate() + daysAfterFriday);
            
            const yyyy = bestByDate.getFullYear();
            const mm = String(bestByDate.getMonth() + 1).padStart(2, '0');
            const dd = String(bestByDate.getDate()).padStart(2, '0');
            return `${yyyy}-${mm}-${dd}`;
        }
        
        function formatDateWithDay(dateString) {
            if (!dateString) return '';
            // Parse yyyy-mm-dd as local date to avoid UTC shift
            const [y, m, d] = dateString.split('-').map(Number);
            const date = new Date(y, (m || 1) - 1, d || 1);
            const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            const dayName = days[date.getDay()];
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const year = date.getFullYear();
            return `${dayName}, ${month}/${day}/${year}`;
        }
        
        function formatInstructions(text) {
            const lines = text.split('\n').filter(line => line.trim());
            const listItems = lines.map(line => {
                // Remove numbering if present and clean up
                return '<li>' + line.replace(/^\d+\.\s*/, '') + '</li>';
            }).join('');
            return '<ol>' + listItems + '</ol>';
        }
        
        // Batch PDF generation with ZIP packaging
        async function downloadAllPDFs() {
            if (filteredDishes.length === 0) {
                alert('No dishes loaded. Please select Season and Rotation first.');
                return;
            }
            
            const bestByDate = document.getElementById('bestBy').value;
            if (!bestByDate) {
                alert('Please enter a Best By Date');
                return;
            }
            
            try {
                const zip = new JSZip();
                const season = document.getElementById('seasonSelect').value;
                const activeBtn = document.querySelector('.rotation-btn.active');
                const rotation = activeBtn ? activeBtn.dataset.rotation || activeBtn.textContent : 'Rotation';
                
                // Show loading message
                const downloadBtn = document.getElementById('downloadAllBtn');
                const originalText = downloadBtn.textContent;
                downloadBtn.textContent = 'Generating PDFs...';
                downloadBtn.disabled = true;
                
                // Generate PDF for each dish
                for (let i = 0; i < filteredDishes.length; i++) {
                    const dish = filteredDishes[i];
                    const pdfBlob = await createPDFForDish(dish, bestByDate);
                    
                    // Create filename: [Name of Dish] - [Subtitle] - [BTP/Meal]
                    const dishNameRaw = (dish['Dish Name'] || 'Label').toString().trim();
                    const subtitleRaw = (dish['Dish Subtitle'] || '').toString().trim();
                    // Exact match logic: 'By the Pound' === 'Yes' -> BTP; otherwise Meal
                    const btpMeal = (dish['By the Pound'] || '') === 'Yes' ? 'BTP' : 'Meal';
                    const sanitized = (str) => str.replace(/[\\/:*?"<>|]+/g, '_').replace(/\s+/g, ' ').trim();
                    const titlePart = subtitleRaw ? `${sanitized(dishNameRaw)} - ${sanitized(subtitleRaw)}` : `${sanitized(dishNameRaw)}`;
                    const filename = `${titlePart} - ${sanitized(btpMeal)}.pdf`;
                    
                    zip.file(filename, pdfBlob);
                }
                
                // Generate ZIP file
                const zipBlob = await zip.generateAsync({type: 'blob'});
                
                // Download ZIP
                const zipFilename = `${season}_${rotation}_labels_${new Date().toISOString().split('T')[0]}.zip`;
                downloadZip(zipBlob, zipFilename);
                
                // Reset button
                downloadBtn.textContent = originalText;
                downloadBtn.disabled = false;
                
            } catch (error) {
                alert('Error generating PDFs. Please try again.');
                
                // Reset button
                const downloadBtn = document.getElementById('downloadAllBtn');
                downloadBtn.textContent = 'Download All PDFs';
                downloadBtn.disabled = false;
            }
        }
        
        // Create PDF for a single dish
        async function createPDFForDish(dishData, bestByDate) {
            // Temporarily update the preview with this dish's data
            const originalIndex = currentLabelIndex;
            const originalDish = filteredDishes[currentLabelIndex];
            
            // Update preview to current dish
            filteredDishes[currentLabelIndex] = dishData;
            updateLabelDisplay();
            
            // Ensure text fitting is applied and synchronized before PDF generation
            await new Promise(resolve => {
                requestAnimationFrame(() => {
                    fitTitleToRow();
                    // Wait for text fitting to complete
                    setTimeout(async () => {
                        // Ensure PDF uses exact same font sizes as preview
                        await FontSyncManager.ensurePDFSync();
                        
                        // Validate synchronization
                        if (!FontSyncManager.validateSync()) {
                            throw new Error('PDF-Preview sync validation failed. PDF generation aborted.');
                        }
                        
                        // Additional visual validation
                        const visualSync = await VisualValidator.validatePDFPreviewSync();
                        if (!visualSync) {
                            throw new Error('Visual sync validation failed. PDF generation aborted.');
                        }
                        
                        resolve();
                    }, 100);
                });
            });
            
            const { jsPDF } = window.jspdf;
            const label = document.getElementById('labelPreview');
            
            // Generate canvas from HTML normally (no bleed capture)
            const canvas = await html2canvas(label, {
                scale: 8, // High scale for sharp print quality (8x = 2400 DPI effective)
                useCORS: true,
                logging: false,
                backgroundColor: '#ffffff'
            });
            
            // Create PDF with bleed area (trim + bleed on all sides)
            const bleed = 0.125; // 1/8" bleed
            const pdf = new jsPDF({
                orientation: 'landscape',
                unit: 'in',
                format: [3 + (bleed * 2), 4 + (bleed * 2)] // Add bleed to both dimensions
            });
            
            const imgData = canvas.toDataURL('image/png');
            
            // Position image in center of PDF (with bleed margins)
            // This creates a clean white bleed area, which is professional and common
            pdf.addImage(imgData, 'PNG', bleed, bleed, 4, 3);
            
            // Restore original state
            filteredDishes[currentLabelIndex] = originalDish;
            currentLabelIndex = originalIndex;
            updateLabelDisplay();
            
            return pdf.output('blob');
        }
        
        // Add crop marks to PDF
        function addCropMarks(pdf, bleed) {
            const cropMarkLength = 0.125; // 1/8 inch
            const cropMarkThickness = 0.005; // Very thin lines
            
            // Set line width and color
            pdf.setLineWidth(cropMarkThickness);
            pdf.setDrawColor(150, 150, 150); // Light gray color
            
            // Top-left crop mark
            pdf.line(bleed - cropMarkLength, bleed, bleed + cropMarkLength, bleed);
            pdf.line(bleed, bleed - cropMarkLength, bleed, bleed + cropMarkLength);
            
            // Top-right crop mark
            pdf.line(4 + bleed - cropMarkLength, bleed, 4 + bleed + cropMarkLength, bleed);
            pdf.line(4 + bleed, bleed - cropMarkLength, 4 + bleed, bleed + cropMarkLength);
            
            // Bottom-left crop mark
            pdf.line(bleed - cropMarkLength, 3 + bleed, bleed + cropMarkLength, 3 + bleed);
            pdf.line(bleed, 3 + bleed - cropMarkLength, bleed, 3 + bleed + cropMarkLength);
            
            // Bottom-right crop mark
            pdf.line(4 + bleed - cropMarkLength, 3 + bleed, 4 + bleed + cropMarkLength, 3 + bleed);
            pdf.line(4 + bleed, 3 + bleed - cropMarkLength, 4 + bleed, 3 + bleed + cropMarkLength);
        }
        
        // Download ZIP file
        function downloadZip(zipBlob, filename) {
            const url = URL.createObjectURL(zipBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function printLabel() {
            window.print();
        }
        
        async function generatePDF() {
            if (filteredDishes.length === 0) {
                alert('No dishes loaded. Please select Season and Rotation first.');
                return;
            }
            
            const bestByDate = document.getElementById('bestBy').value;
            if (!bestByDate) {
                alert('Please enter a Best By Date');
                return;
            }
            
            const dish = filteredDishes[currentLabelIndex];
            const pdfBlob = await createPDFForDish(dish, bestByDate);
            
            // Create filename: [Name of Dish] - [Subtitle] - [BTP/Meal]
            const dishNameRaw = (dish['Dish Name'] || 'Label').toString().trim();
            const subtitleRaw = (dish['Dish Subtitle'] || '').toString().trim();
            // Exact match logic: 'By the Pound' === 'Yes' -> BTP; otherwise Meal
            const btpMeal = (dish['By the Pound'] || '') === 'Yes' ? 'BTP' : 'Meal';
            const sanitized = (str) => str.replace(/[\\/:*?"<>|]+/g, '_').replace(/\s+/g, ' ').trim();
            const titlePart = subtitleRaw ? `${sanitized(dishNameRaw)} - ${sanitized(subtitleRaw)}` : `${sanitized(dishNameRaw)}`;
            const filename = `${titlePart} - ${sanitized(btpMeal)}.pdf`;
            
            // Download single PDF
            const url = URL.createObjectURL(pdfBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
            // Initialize with today's dates and load sheet data
        window.onload = async function() {
            
            // Show loading indicator initially
            showLoading();
            
                // Temporary initial Best By (1 day less than prior logic): next Friday + 4 days
                document.getElementById('bestBy').value = calculateBestByDate(4);
            
            // Load dish data from Google Sheets
            await fetchDishesFromSheet();
            
            
            // Auto-load first season and rotation if available
            if (allDishes.length > 0) {
                const seasons = [...new Set(allDishes.map(dish => dish.Season).filter(Boolean))];
                
                if (seasons.length > 0) {
                    const firstSeason = seasons[0];
                    document.getElementById('seasonSelect').value = firstSeason;
                    populateRotationDropdown(firstSeason);
                    
                    const rotations = [...new Set(allDishes
                        .filter(dish => dish.Season === firstSeason)
                        .map(dish => dish.Rotation)
                        .filter(Boolean))];
                    
                    
                    if (rotations.length > 0) {
                        const firstRotation = rotations[0];
                        // Click the first rotation button to load labels
                        setTimeout(() => {
                            const firstBtn = document.querySelector('.rotation-btn');
                            if (firstBtn) {
                                firstBtn.click();
                            }
                        }, 100);
                    }
                }
            } else {
                // Keep loading indicator visible if no data
            }
            
            // Initialize scaling after content exists
            initializePreviewScaling();
            
            // Season change handler
            const seasonSelect = document.getElementById('seasonSelect');
            seasonSelect.addEventListener('change', (e) => {
                populateRotationDropdown(e.target.value);
                // Clear any active rotation buttons when season changes
                document.querySelectorAll('.rotation-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                // Reset manual edit flag so defaults apply for new selection
                window.__userEditedBestBy = false;
            });
            
            // Best By date change handler
            const bestByInput = document.getElementById('bestBy');
            bestByInput.addEventListener('change', () => {
                // Mark that user manually edited date so we don't override on navigation
                window.__userEditedBestBy = true;
                if (filteredDishes.length > 0) {
                    updateLabelDisplay();
                }
            });
            
            // Grid toggle handler
            const gridToggle = document.getElementById('toggleGridLines');
            const label = document.getElementById('labelPreview');
            if (gridToggle && label) {
                gridToggle.addEventListener('change', () => {
                    if (gridToggle.checked) {
                        label.classList.add('show-grid');
                    } else {
                        label.classList.remove('show-grid');
                    }
                });
            }
            
            // Initial branding
            applyBranding();
            
            // Ensure text fitting runs after everything is loaded
            setTimeout(() => {
                fitTitleToRow();
            }, 500);
        };

        // Branding application based on color selection
        function applyBranding() {
            // Get color from current dish data
            const dish = filteredDishes[currentLabelIndex];
            const chosen = dish && dish.Color ? dish.Color.toLowerCase() : 'green';
            const labelEl = document.querySelector('.label');
            const rowEl = document.querySelector('.cell-1');
            const logoImg = document.getElementById('brandLogo');
            const brandTitle = document.querySelector('.brand-title');
            const useMap = {
                green: 'var(--color-green)',
                orange: 'var(--color-orange)',
                gray: 'var(--color-gray)',
                red: 'var(--color-red)',
                blue: 'var(--color-blue)'
            };
            const bg = useMap[chosen] || useMap.green;
            if (rowEl) {
                rowEl.style.setProperty('--brand-bg', bg);
            }
            // Logo and text color switching
            const isGray = chosen === 'gray';
            const whiteLogo = 'images/logos/White Logo Suite/HMC_Vertical Full Lockup_White [RGB].png';
            const blackLogo = 'images/logos/Black Logo Suite/HMC_Vertical Full Lockup_Black [RGB].png';
            if (logoImg) logoImg.src = isGray ? blackLogo : whiteLogo;
            if (brandTitle) {
                brandTitle.style.color = isGray ? '#000' : '#fff';
            }
        }

        // Enhanced text fitting with better scaling algorithm
        function fitTitleToRow() {
            const rowEl = document.querySelector('.cell-1');
            const logoImg = document.getElementById('brandLogo');
            const titleEl = document.getElementById('previewDish');
            const subtitleEl = document.getElementById('previewSubtitle');
            
            // Future-proof validation: ensure all required elements exist
            if (!rowEl || !logoImg || !titleEl || !subtitleEl) {
                return;
            }
            
            // Future-proof validation: ensure FontSyncManager is available
            if (typeof FontSyncManager === 'undefined') {
                return;
            }
            
            // Reset to CSS defaults first
            titleEl.style.fontSize = '';
            subtitleEl.style.fontSize = '';
            
            // Wait for CSS to apply, then measure
            requestAnimationFrame(() => {
                // Get available space - account for padding and line-height
                const logoHeight = logoImg.getBoundingClientRect().height;
                const containerHeight = rowEl.getBoundingClientRect().height;
                const brandTitle = titleEl.parentElement; // .brand-title element
                const titlePadding = brandTitle ? 4 : 0; // 2px top + 2px bottom
                const availableHeight = Math.min(logoHeight, containerHeight) - titlePadding; // account for container padding
                
                const titleContainer = titleEl.parentElement;
                const availableWidth = titleContainer.getBoundingClientRect().width - 2; // minimal padding
                
                // Start with optimized default sizes
                let titleSize = 28; // pt
                let subtitleSize = 20; // pt
                
                // Debug: log all space measurements
                
                
                
                // Create a temporary measurement element
                const createMeasurer = () => {
                    const measurer = document.createElement('div');
                    measurer.style.position = 'absolute';
                    measurer.style.visibility = 'hidden';
                    measurer.style.whiteSpace = 'nowrap';
                    measurer.style.height = 'auto';
                    measurer.style.width = 'auto';
                    measurer.style.overflow = 'visible';
                    document.body.appendChild(measurer);
                    return measurer;
                };
                
                const removeMeasurer = (measurer) => {
                    document.body.removeChild(measurer);
                };
                
                // Function to check if individual text fits horizontally
                const checkTitleFits = (size) => {
                    const measurer = createMeasurer();
                    measurer.style.fontSize = size + 'pt';
                    measurer.style.fontWeight = titleEl.style.fontWeight || '800';
                    measurer.textContent = titleEl.textContent;
                    
                    const textWidth = measurer.offsetWidth;
                    removeMeasurer(measurer);
                    return textWidth <= availableWidth;
                };
                
                const checkSubtitleFits = (size) => {
                    const measurer = createMeasurer();
                    measurer.style.fontSize = size + 'pt';
                    measurer.style.fontStyle = 'italic';
                    measurer.style.fontWeight = subtitleEl.style.fontWeight || '400';
                    measurer.textContent = subtitleEl.textContent;
                    
                    const textWidth = measurer.offsetWidth;
                    removeMeasurer(measurer);
                    return textWidth <= availableWidth;
                };
                
                // Function to check if text fits vertically
                const checkVerticalFit = () => {
                    const titleHeight = titleEl.getBoundingClientRect().height;
                    const subtitleHeight = subtitleEl.getBoundingClientRect().height;
                    const totalHeight = titleHeight + subtitleHeight;
                    const fits = totalHeight <= availableHeight;
                    
                    
                    return fits;
                };
                
                // Scale each element independently
                const scaleElement = (startSize, checkFunction, minSize, elementName) => {
                    let currentSize = startSize;
                    let iterations = 0;
                    const maxIterations = 50;
                    
                    while (iterations < maxIterations) {
                        if (checkFunction(currentSize)) {
                            break;
                        }
                        
                        currentSize *= 0.90; // Scale down by 10% per iteration (faster scaling)
                        currentSize = Math.max(minSize, currentSize);
                        
                        if (Math.abs(currentSize - minSize) < 0.1) {
                            break;
                        }
                        
                        iterations++;
                    }
                    
                    return currentSize;
                };
                
                // Scale title independently
                const finalTitleSize = scaleElement(titleSize, checkTitleFits, 18, 'Title');
                
                // Scale subtitle independently  
                const finalSubtitleSize = scaleElement(subtitleSize, checkSubtitleFits, 13, 'Subtitle');
                
                // Apply the independently scaled sizes
                titleEl.style.fontSize = finalTitleSize + 'pt';
                subtitleEl.style.fontSize = finalSubtitleSize + 'pt';
                
                // Check if both fit vertically after independent scaling
                const totalHeight = titleEl.getBoundingClientRect().height + subtitleEl.getBoundingClientRect().height;
                if (totalHeight > availableHeight) {
                    const scaleFactor = availableHeight / totalHeight;
                    const scaledTitleSize = Math.max(16, finalTitleSize * scaleFactor);
                    const scaledSubtitleSize = Math.max(11, finalSubtitleSize * scaleFactor);
                    
                    titleEl.style.fontSize = scaledTitleSize + 'pt';
                    subtitleEl.style.fontSize = scaledSubtitleSize + 'pt';
                    
                    titleSize = scaledTitleSize;
                    subtitleSize = scaledSubtitleSize;
                } else {
                    titleSize = finalTitleSize;
                    subtitleSize = finalSubtitleSize;
                }
                
                // Apply final sizes using the sync manager
                FontSyncManager.applyFontSizes(titleSize, subtitleSize);
                
            });
        }

        // Visual validation system for PDF-preview sync
        const VisualValidator = {
            // Take a screenshot of the preview for comparison
            capturePreviewSnapshot() {
                const label = document.getElementById('labelPreview');
                if (!label) return null;
                
                return new Promise((resolve) => {
                    html2canvas(label, {
                        scale: 8, // Match PDF generation scale
                        useCORS: true,
                        logging: false,
                        backgroundColor: '#ffffff'
                    }).then(canvas => {
                        resolve(canvas.toDataURL());
                    }).catch(() => resolve(null));
                });
            },
            
            // Validate that preview and PDF would be identical
            async validatePDFPreviewSync() {
                const snapshot = await this.capturePreviewSnapshot();
                if (!snapshot) return false;
                
                // Store snapshot for debugging
                this.lastSnapshot = snapshot;
                
                // Check if font sizes are properly synchronized
                const isSynced = FontSyncManager.validateSync();
                
                if (!isSynced) {
                    return false;
                }
                
                return true;
            }
        };

        // Preview scaling logic (on-screen only)
        function initializePreviewScaling() {
            // Set up resize observer for dynamic text scaling
            if (window.ResizeObserver) {
                const resizeObserver = new ResizeObserver(() => {
                    // Debounce the text fitting to avoid excessive calls
                    clearTimeout(window.textFitTimeout);
                    window.textFitTimeout = setTimeout(() => {
                        fitTitleToRow();
                        // Validate sync after text fitting
                        VisualValidator.validatePDFPreviewSync();
                    }, 100);
                });
                
                const labelPreview = document.getElementById('labelPreview');
                if (labelPreview) {
                    resizeObserver.observe(labelPreview);
                }
            }
        }
    </script>
</body>
</html>