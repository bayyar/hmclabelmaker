<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meal Label Generator</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Karla:wght@300;400;500;600;700;800&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --color-orange: #A15408;
            --color-gray: #BDC7C3;
            --color-red: #520212;
            --color-blue: #003854;
            --color-green: #444E20;
        }
        
        body {
            font-family: 'Karla', sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }
        
        .app-container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .app-header {
            background: white;
            padding: 20px 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .app-header h1 {
            color: #333;
            font-weight: 700;
            font-size: 28px;
            margin: 0;
        }
        
        .header-actions {
            display: flex;
            gap: 10px;
        }
        
        .main-layout {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
        }
        
        .preview-section {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 600px;
        }
        
        .label-navigation {
            display: none; /* Hide from preview section - moved to controls */
        }
        
        /* On-screen actual-size preview helpers */
        .scale-wrapper {
            transform-origin: top left;
        }
        
        .preview-scale-controls {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }
        
        .preview-scale-row {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }
        
        .calibration-box {
            width: 1in;
            height: 1in;
            border: 2px dashed #9ca3af;
            background: repeating-linear-gradient(90deg, transparent, transparent 0.25in, rgba(37,99,235,0.08) 0.25in, rgba(37,99,235,0.08) 0.26in),
                        repeating-linear-gradient(0deg, transparent, transparent 0.25in, rgba(37,99,235,0.08) 0.25in, rgba(37,99,235,0.08) 0.26in);
        }
        
        .scale-slider {
            flex: 1 1 200px;
        }
        
        .scale-percent-input {
            width: 80px;
        }
        
        .preview-section h2 {
            margin-bottom: 20px;
            color: #333;
            font-weight: 700;
            font-size: 20px;
            align-self: flex-start;
        }
        
        .controls-section {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            height: fit-content;
        }
        
        .controls-section h3 {
            margin-bottom: 20px;
            color: #333;
            font-weight: 700;
            font-size: 18px;
        }
        
        /* Elegant navigation controls */
        .label-navigation {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 25px;
            padding: 20px 0;
            background: transparent; /* Remove background shading */
            border-radius: 0;
            border: none;
        }
        
        .label-counter {
            text-align: center;
            font-weight: 600;
            color: #334155;
            font-size: 16px;
            margin-bottom: 5px;
        }
        
        .nav-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        .nav-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            min-width: 80px;
        }
        
        .nav-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        
        .nav-button:active {
            transform: translateY(0);
        }
        
        .nav-button:disabled {
            background: #cbd5e1;
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .nav-button:disabled:hover {
            transform: none;
        }
        
        .form-group {
            display: flex;
            flex-direction: column;
            margin-bottom: 18px;
        }
        
        label {
            font-weight: 600;
            margin-bottom: 5px;
            color: #555;
            font-size: 13px;
        }
        
        input, textarea, select {
            padding: 12px 10px; /* Match button height */
            border: 1px solid #ddd;
            border-radius: 5px;
            font-family: inherit;
            font-size: 14px;
            width: 100%;
            height: 44px; /* Match button height */
            box-sizing: border-box;
        }
        
        textarea {
            resize: vertical;
            min-height: 70px;
            height: auto; /* Override fixed height for textarea */
        }
        
        .button-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 24px;
        }
        
        button {
            background: #2563eb;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 5px;
            font-weight: 600;
            cursor: pointer;
            font-size: 15px;
            width: 100%;
            height: 44px; /* Match input height */
            box-sizing: border-box;
            transition: background-color 0.2s ease;
        }
        
        button:hover {
            background: #1d4ed8;
        }
        
        button.secondary {
            background: #6b7280;
        }
        
        button.secondary:hover {
            background: #4b5563;
        }
        
        button:disabled {
            background: #cbd5e1;
            cursor: not-allowed;
        }
        
        button:disabled:hover {
            background: #cbd5e1;
        }
        
        /* Mobile responsive layout */
        @media (max-width: 968px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
            
            .preview-section {
                order: 1;
            }
            
            .controls-section {
                order: 2;
            }
        }
        
        /* Label Styles - 3x4 Grid System */
        .label {
            width: 100%;
            max-width: 600px;
            height: auto;
            aspect-ratio: 4/3;
            background: white;
            padding: 0;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 30% 30% 40%;
            grid-template-rows: 0.6fr 2.4fr; /* Top row 20%, bottom area 80% */
            gap: 0;
            position: relative;
            font-family: 'Karla', sans-serif;
            box-sizing: border-box;
            /* No border for preview - clean appearance */
            border: none;
            box-shadow: none;
            outline: none;
            z-index: 10;
        }
        
        .loading-indicator {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 600px;
            height: auto;
            aspect-ratio: 4/3;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin: 0 auto;
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #2563eb;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-text {
            color: #666;
            font-size: 16px;
            font-weight: 500;
        }
        
        /* Bleed area - extends beyond trim for professional printing */
        .label::before {
            content: '';
            position: absolute;
            top: -0.125in; /* 1/8" bleed */
            left: -0.125in;
            right: -0.125in;
            bottom: -0.125in;
            background: white;
            z-index: -2;
            border-radius: 0;
            /* Dotted border for bleed area */
            border: 1px dotted #000;
            /* Ensure this doesn't cover the main border */
            pointer-events: none;
        }
        
        /* Bleed area background for top row - extends brand color to bleed edges */
        .label::after {
            content: '';
            position: absolute;
            top: -0.125in;
            left: -0.125in;
            right: -0.125in;
            height: calc(20% + 0.125in); /* Top row height + bleed */
            background: var(--brand-bg, var(--color-green));
            z-index: -1;
            pointer-events: none;
        }
        
        /* Grid lines overlay */
        .grid-guides {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            display: none;
            z-index: 5;
            /* Light red grid lines */
            background-image:
                /* Vertical lines */
                linear-gradient(to right, rgba(255,0,0,0.3) 0%, rgba(255,0,0,0.3) 1px, transparent 1px),
                linear-gradient(to right, rgba(255,0,0,0.3) 0%, rgba(255,0,0,0.3) 1px, transparent 1px),
                /* Horizontal line at 20% */
                linear-gradient(to bottom, rgba(255,0,0,0.3) 0%, rgba(255,0,0,0.3) 1px, transparent 1px);
            background-repeat: no-repeat;
            background-size: 100% 100%, 100% 100%, 100% 100%;
            background-position: 30% 0, 60% 0, 0 20%;
        }
        .label.show-grid .grid-guides { display: block; }
        
        /* Crop marks at corners of 3x4 border */
        .crop-marks {
            position: absolute;
            top: -0.125in;
            left: -0.125in;
            right: -0.125in;
            bottom: -0.125in;
            pointer-events: none;
            z-index: 10;
            display: none;
        }
        
        .crop-marks::before {
            content: '';
            position: absolute;
            /* Top-left crop mark */
            top: 0;
            left: 0;
            width: 0.125in;
            height: 0.125in;
            border-top: 2px solid #000;
            border-left: 2px solid #000;
        }
        
        .crop-marks::after {
            content: '';
            position: absolute;
            /* Top-right crop mark */
            top: 0;
            right: 0;
            width: 0.125in;
            height: 0.125in;
            border-top: 2px solid #000;
            border-right: 2px solid #000;
        }
        
        .crop-marks .bottom-left {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 0.125in;
            height: 0.125in;
            border-bottom: 2px solid #000;
            border-left: 2px solid #000;
        }
        
        .crop-marks .bottom-right {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 0.125in;
            height: 0.125in;
            border-bottom: 2px solid #000;
            border-right: 2px solid #000;
        }
        
        .label.show-grid .crop-marks { display: block; }

        /* Comprehensive grid guide overlay */
        .grid-guides {
            position: absolute;
            /* align guides with the content area (inside padding) */
            top: 0.15in; left: 0.15in; right: 0.15in; bottom: 0.15in;
            pointer-events: none;
            display: none;
            /* All column and row dividers */
            background-image:
                /* Column dividers at 30% and 60% */
                linear-gradient(to right, rgba(255,0,0,0.3) 0%, rgba(255,0,0,0.3) 1px, transparent 1px),
                linear-gradient(to right, rgba(255,0,0,0.3) 0%, rgba(255,0,0,0.3) 1px, transparent 1px),
                /* Row dividers at ~33% and 66% of remaining rows */
                linear-gradient(to bottom, rgba(255,0,0,0.3) 0%, rgba(255,0,0,0.3) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(255,0,0,0.3) 0%, rgba(255,0,0,0.3) 1px, transparent 1px);
            background-repeat: no-repeat;
            background-size: 100% 100%, 100% 100%, 100% 100%, 100% 100%;
            background-position: 30% 0, 60% 0, 0 calc(0.6fr / (0.6fr + 1.2fr + 1.2fr) * 100%), 0 calc((0.6fr + 1.2fr) / (0.6fr + 1.2fr + 1.2fr) * 100%);
            /* Outer border */
            outline: 1px solid rgba(255,0,0,0.3);
        }
        .label.show-grid .grid-guides { display: block; }

        
        /* Cell 1 - Logo (spans all columns in row 1) */
        .cell-1 {
            grid-column: 1 / 4;
            grid-row: 1;
            display: flex;
            align-items: stretch;
            justify-content: flex-start;
            padding: 8px;
            background: transparent;
            gap: 10px;
            min-height: 0;
            position: relative;
            z-index: 1;
        }
        .cell-1::before {
            content: '';
            position: absolute;
            /* Extend background to bleed area edges */
            top: -0.125in;
            left: -0.125in;
            right: -0.125in;
            bottom: 0;
            background: var(--brand-bg, var(--color-green));
            z-index: -1;
        }
        .cell-1 > * { position: relative; z-index: 2; }
        
        .logo-container {
            height: 100%;
            display: flex;
            align-items: stretch;
        }
        
        .logo-container img {
            height: 100%;
            width: auto;
            object-fit: contain;
            display: block;
            transform: scale(1.2); /* Increase logo size by 20% */
        }
        
        /* Cell 2 - Empty/Company Info */
        .cell-2 { display: none; }
        
        /* Cell 3 - Best By and Weight */
        .cell-3 { display: none; }
        
        .cell-3 .date-item {
            margin-bottom: 4px;
        }
        
        .cell-3 .label-text {
            font-weight: 700;
            font-size: 0.875em; /* 7pt equivalent for screen, maintains 7pt minimum for print */
        }
        
        .cell-3 .date-value {
            font-size: 0.875em; /* 7pt equivalent for screen, maintains 7pt minimum for print */
            font-weight: 400;
        }
        
        .cell-3 .weight-text {
            font-weight: 400;
            margin-top: 2px;
            font-size: 0.875em; /* 7pt equivalent for screen, maintains 7pt minimum for print */
        }
        
        .cell-3 .weight-label {
            font-weight: 700;
        }
        
        /* Title next to logo in row 1 */
        .brand-title {
            display: flex;
            flex-direction: column;
            justify-content: center;
            color: #fff;
            flex: 1 1 auto;
            overflow: hidden;
            text-align: left; /* left align the title text */
        }

        .brand-title h4 {
            font-size: 4.5em; /* Larger base size - JavaScript will override for scaling */
            font-weight: 800;
            line-height: 1;
            color: inherit;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .brand-title .dish-subtitle {
            font-size: 3em; /* Larger base size - JavaScript will override for scaling */
            font-weight: 400;
            font-style: italic;
            color: inherit;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        /* Cells 6, 9 - Ingredients and Info (merged) */
        .cell-6-9 {
            grid-column: 3;
            grid-row: 2;
            display: flex;
            flex-direction: column;
            line-height: 1.3;
            padding: 12px;
            background: transparent; /* Remove gray background */
            overflow: hidden;
            font-size: 0.875em; /* Ensure consistent base font size */
            border: none; /* Remove border */
            border-radius: 0; /* Remove border radius */
            margin: 0; /* Remove margin for proper alignment */
            border-left: 2px solid #ddd; /* Add vertical line separator */
            margin-left: 8px; /* Add some space from the separator */
        }
        
        .cell-6-9 .ingredients-label {
            font-weight: 700;
            margin-bottom: 4px; /* Consistent spacing */
        }
        
        .ingredients-list {
            color: #333;
            margin-bottom: 8px; /* Consistent spacing */
            line-height: 1.3;
            font-weight: 400;
        }
        
        .allergens-section {
            padding-top: 6px;
            border-top: 1px solid #ddd;
            border-bottom: 1px solid #ddd;
            padding-bottom: 8px; /* Increased padding-bottom to match margin-top for better spacing */
        }
        
        .allergens-label {
            font-weight: 700;
        }

        .subsection-label {
            font-weight: 700;
        }

        .meta-text {
            color: #333;
            font-weight: 400;
        }
        
        .meta-block {
            padding: 8px 0; /* 8px vertical padding for the entire meta block */
        }
        
        .meta-row {
            padding: 2px 0; /* 2px vertical padding for Best By and Net Weight */
        }
        
        .allergens-text {
            color: #333;
            font-weight: 400;
        }
        
        .company-info {
            padding-top: 8px;
            padding-bottom: 4px;
            border-top: 1px solid #ddd;
            color: #444;
            font-weight: 400;
            font-size: 0.8125em; /* Smaller font size to match 6.5pt print size */
        }
        
        .company-name {
            font-weight: 600;
            margin-bottom: 2px;
            font-size: 0.8125em; /* Smaller font size to match 6.5pt print size */
        }
        
        /* Cells 7-8 - Heating Instructions */
        .cell-7-8 {
            grid-column: 1 / 3;
            grid-row: 2;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            padding: 12px 8px 8px 8px; /* Match top padding with right column */
            font-size: 0.875em; /* Match font size with right column */
        }
        
        .chef-instructions, .fast-instructions {
            display: flex;
            flex-direction: column;
        }
        
        .instructions-title {
            font-weight: 700;
            margin-bottom: 4px;
        }
        
        .instructions-text {
            line-height: 1.4;
            color: #333;
            font-weight: 400;
        }
        
        .instructions-text ol {
            padding-left: 14px;
            margin: 0;
        }
        
        .instructions-text li {
            margin-bottom: 2px;
        }
        
        /* Print styles */
        @media print {
            body {
                background: white;
                padding: 0;
            }
            
            .app-header, .controls-section, .preview-section h2 {
                display: none !important;
            }
            
            .main-layout {
                display: block;
            }
            
            .preview-section {
                box-shadow: none;
                padding: 0;
            }
            
            .label {
                border: none !important; /* Remove black border for printing */
                page-break-after: always;
                width: 4.5in !important; /* Include bleed in print */
                height: 3.5in !important;
            }
            
            /* Preserve JavaScript-applied font sizes for print/PDF */
            .brand-title h4 {
                font-size: inherit !important; /* Use JavaScript-applied size */
            }
            
            .brand-title .dish-subtitle {
                font-size: inherit !important; /* Use JavaScript-applied size */
            }
            
            /* Fallback larger sizes if JavaScript doesn't apply */
            .brand-title h4:not([style*="font-size"]) {
                font-size: 35pt !important; /* Larger fallback size */
            }
            
            .brand-title .dish-subtitle:not([style*="font-size"]) {
                font-size: 25pt !important; /* Larger fallback size */
            }
            
            .cell-3 .label-text,
            .cell-3 .date-value,
            .cell-3 .weight-text {
                font-size: 7pt !important;
            }
            
            .cell-6-9 {
                font-size: 7pt !important; /* All child elements inherit this font size */
            }
            
            .company-info,
            .company-name {
                font-size: 6.5pt !important; /* Company info uses slightly larger 6.5pt font */
            }
            
            .cell-7-8 {
                font-size: 7pt !important; /* All child elements inherit this font size */
            }
            
            /* Ensure on-screen transforms do not affect print */
            .scale-wrapper {
                transform: none !important;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="app-header">
            <h1>Hudson Meal Co. Label Generator</h1>
            <div class="header-actions">
                <button class="nav-button" onclick="window.open('https://docs.google.com/spreadsheets/d/1UugIwrAyHXOAgBrQcU9zFwIEOYg9-baJdoGCWSMIJNk/edit?gid=0#gid=0', '_blank')">Edit CSV</button>
            </div>
        </div>
        
        <div class="main-layout">
            <div class="preview-section">
                <div class="scale-wrapper" id="scaleWrapper">
                    <!-- Loading indicator -->
                    <div class="loading-indicator" id="loadingIndicator">
                        <div class="loading-spinner"></div>
                        <div class="loading-text">Loading label data...</div>
                    </div>
                    
                    <!-- Label preview (hidden initially) -->
                    <div class="label" id="labelPreview" style="display: none;">
                    <div class="grid-guides" aria-hidden="true"></div>
                    <div class="crop-marks" aria-hidden="true">
                        <div class="bottom-left"></div>
                        <div class="bottom-right"></div>
                    </div>
                    <!-- Cell 1: Logo + Title (spans all columns) -->
                    <div class="cell-1">
                        <div class="logo-container">
                            <img id="brandLogo" src="images/logos/White Logo Suite/HMC_Vertical Full Lockup_White [RGB].png" alt="Hudson Meal Co Logo" />
                        </div>
                        <div class="brand-title">
                            <h4 id="previewDish">Select Season and Rotation</h4>
                            <div class="dish-subtitle" id="previewSubtitle">to load labels</div>
                        </div>
                    </div>
                    
                    <!-- Cell 2: Empty/Available -->
                    <div class="cell-2">
                        <!-- Empty for now -->
                    </div>
                    
                    <!-- Cell 3 removed; Best By/Weight moved under allergens -->
                    
                    <!-- Cells 4-5: removed (content moved to row 1) -->
                    
                    <!-- Cells 6 & 9: Ingredients & Info -->
                    <div class="cell-6-9">
                        <div class="ingredients-label">Ingredients:</div>
                        <div class="ingredients-list" id="previewIngredients">Please select a season and rotation to load dish data</div>
                        <div class="allergens-section">
                            <span class="allergens-label">Allergens:</span>
                            <span class="allergens-text" id="previewAllergens">-</span>
                        </div>
                        <div class="meta-block">
                            <div class="meta-row">
                                <span class="subsection-label">Best By:</span>
                                <span class="meta-text" id="previewBestBy">-</span>
                            </div>
                            <div class="meta-row">
                                <span class="subsection-label">Net Weight:</span>
                                <span class="meta-text" id="previewWeight">-</span>
                            </div>
                        </div>
                        <div class="company-info">
                            <div class="company-name">Hudson Meal Co. LLC</div>
                            <div>hudsonmealco.com</div>
                            <div style="margin-top: 4px;">86 Broad Street</div>
                            <div>Kinderhook, NY 12106</div>
                        </div>
                    </div>
                    
                    <!-- Cells 7-8: Heating Instructions -->
                    <div class="cell-7-8">
                        <div class="chef-instructions">
                            <div class="instructions-title">Chef Instructions:</div>
                            <div class="instructions-text" id="previewChefInstructions">
                                <ol>
                                    <li>Please select a season and rotation</li>
                                </ol>
                            </div>
                        </div>
                        <div class="fast-instructions">
                            <div class="instructions-title">Fast Instructions:</div>
                            <div class="instructions-text" id="previewFastInstructions">
                                <ol>
                                    <li>Please select a season and rotation</li>
                                </ol>
                            </div>
                        </div>
                    </div>
                    </div>
                </div>
            </div>
            
            <div class="controls-section">
                <h3>Label Selection</h3>
                <div class="form-group">
                    <label for="seasonSelect">Season</label>
                    <select id="seasonSelect">
                        <option value="">Select Season</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="rotationSelect">Rotation</label>
                    <select id="rotationSelect" disabled>
                        <option value="">Select Rotation</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="bestBy">Best By Date</label>
                    <input type="date" id="bestBy" />
                </div>
                
                <!-- Horizontal separator -->
                <div style="border-top: 1px solid #e2e8f0; margin: 20px 0;"></div>
                
                <!-- Elegant Navigation Controls -->
                <div class="label-navigation">
                    <div class="label-counter" id="labelCounter">Label 1 of 1</div>
                    <div class="nav-buttons">
                        <button class="nav-button" id="prevLabel" onclick="previousLabel()">← Previous</button>
                        <button class="nav-button" id="nextLabel" onclick="nextLabel()">Next →</button>
                    </div>
                </div>
                
                <!-- Horizontal separator -->
                <div style="border-top: 1px solid #e2e8f0; margin: 20px 0;"></div>
                
                <div class="button-group">
                    <button onclick="generatePDF()" id="downloadSingleBtn" disabled>Download Current PDF</button>
                    <button onclick="downloadAllPDFs()" id="downloadAllBtn" disabled class="secondary">Download All PDFs</button>
                </div>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        // Global variables for dish data and current state
        let allDishes = [];
        let filteredDishes = [];
        let currentLabelIndex = 0;
        
        /*
         * PDF-PREVIEW SYNCHRONIZATION SYSTEM
         * 
         * This system ensures that PDFs and previews are always visually identical (1:1 match).
         * 
         * CRITICAL: Any changes to font sizing MUST go through FontSyncManager.applyFontSizes()
         * to maintain synchronization. Direct style.fontSize changes will break sync.
         * 
         * How it works:
         * 1. FontSyncManager tracks all applied font sizes
         * 2. PDF generation uses the same sizes as preview
         * 3. VisualValidator confirms sync before PDF generation
         * 4. Future-proof safeguards prevent sync breaks
         * 
         * To maintain sync in future iterations:
         * - Always use FontSyncManager.applyFontSizes() for font changes
         * - Never directly modify style.fontSize on title/subtitle elements
         * - Test PDF generation after any font-related changes
         * - Check console for sync validation warnings
         */
        const FontSyncManager = {
            appliedSizes: {
                title: null,
                subtitle: null
            },
            
            // Apply font sizes consistently
            applyFontSizes(titleSize, subtitleSize) {
                const titleEl = document.getElementById('previewDish');
                const subtitleEl = document.getElementById('previewSubtitle');
                
                if (titleEl && subtitleEl) {
                    // Force override any CSS constraints
                    titleEl.style.fontSize = titleSize + 'pt !important';
                    subtitleEl.style.fontSize = subtitleSize + 'pt !important';
                    
                    // Also set without !important for compatibility
                    titleEl.style.setProperty('font-size', titleSize + 'pt', 'important');
                    subtitleEl.style.setProperty('font-size', subtitleSize + 'pt', 'important');
                    
                    // Store for PDF generation
                    this.appliedSizes.title = titleSize;
                    this.appliedSizes.subtitle = subtitleSize;
                    
                    // Add data attributes for debugging
                    titleEl.setAttribute('data-sync-title-size', titleSize + 'pt');
                    subtitleEl.setAttribute('data-sync-subtitle-size', subtitleSize + 'pt');
                    
                    console.log(`FontSyncManager: Applied Title=${titleSize}pt, Subtitle=${subtitleSize}pt`);
                    console.log('Actual computed styles:', {
                        title: window.getComputedStyle(titleEl).fontSize,
                        subtitle: window.getComputedStyle(subtitleEl).fontSize
                    });
                }
            },
            
            // Ensure PDF uses same sizes as preview
            ensurePDFSync() {
                return new Promise((resolve) => {
                    // Force reflow to ensure sizes are applied
                    requestAnimationFrame(() => {
                        const titleEl = document.getElementById('previewDish');
                        const subtitleEl = document.getElementById('previewSubtitle');
                        
                        if (titleEl && subtitleEl && this.appliedSizes.title && this.appliedSizes.subtitle) {
                            // Re-apply the exact same sizes
                            titleEl.style.fontSize = this.appliedSizes.title + 'pt';
                            subtitleEl.style.fontSize = this.appliedSizes.subtitle + 'pt';
                            
                            // Wait for browser to process the changes
                            setTimeout(resolve, 150);
                        } else {
                            resolve();
                        }
                    });
                });
            },
            
            // Validate that sizes are consistent
            validateSync() {
                const titleEl = document.getElementById('previewDish');
                const subtitleEl = document.getElementById('previewSubtitle');
                
                if (!titleEl || !subtitleEl) return false;
                
                const currentTitleSize = parseFloat(titleEl.style.fontSize);
                const currentSubtitleSize = parseFloat(subtitleEl.style.fontSize);
                
                const isSynced = (
                    this.appliedSizes.title === currentTitleSize &&
                    this.appliedSizes.subtitle === currentSubtitleSize
                );
                
                if (!isSynced) {
                    console.warn('FontSyncManager: Sync validation failed!', {
                        expected: this.appliedSizes,
                        actual: { title: currentTitleSize, subtitle: currentSubtitleSize }
                    });
                }
                
                return isSynced;
            }
        };
        
        // Google Sheets configuration
        const SHEET_ID = '1UugIwrAyHXOAgBrQcU9zFwIEOYg9-baJdoGCWSMIJNk';
        const SHEET_GID = '0'; // Default sheet (first tab)
        const CSV_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${SHEET_GID}`;
        
        // Fetch dishes from Google Sheets
        async function fetchDishesFromSheet() {
            try {
                console.log('Fetching dishes from Google Sheets...');
                const response = await fetch(CSV_URL);
                console.log('Response status:', response.status);
                console.log('Response headers:', response.headers);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const csvText = await response.text();
                console.log('CSV text preview:', csvText.substring(0, 200));
                
                // Check if we got HTML instead of CSV (redirect page)
                if (csvText.includes('<HTML>') || csvText.includes('<html>')) {
                    console.error('Received HTML instead of CSV - sheet may not be public');
                    throw new Error('Sheet is not publicly accessible. Please ensure the sheet is published to the web.');
                }
                
                allDishes = parseCSV(csvText);
                console.log('Parsed dishes:', allDishes);
                populateSeasonDropdown();
                console.log(`Loaded ${allDishes.length} dishes from Google Sheets`);
            } catch (error) {
                console.error('Error fetching dishes:', error);
                alert('Error loading dish data from Google Sheets. Please check your internet connection and ensure the sheet is published to the web.');
                
                // Load sample data for testing
                loadSampleData();
            }
        }
        
        // Load sample data for testing when Google Sheets is not accessible
        function loadSampleData() {
            console.log('Loading sample data for testing...');
            allDishes = [
                {
                    'Season': 'Fall 2024',
                    'Rotation': 'Week 1',
                    'Dish Name': 'Braised Beef',
                    'Dish Subtitle': 'with Chimichurri Sauce',
                    'Net Weight': '1 lb',
                    'Ingredients': 'Grimaldi Farm grassfed organic beef, cilantro, parsley, organic extra-virgin olive oil, salt, red wine vinegar, black pepper, garlic, cumin',
                    'Allergens': 'None',
                    'Chef Instructions': '1. Preheat oven to 350°F\n2. Remove sleeve and film\n3. Remove sauce and trim\n4. Heat up 10-15 mins or until heated thoroughly\n5. Pour sauce on top',
                    'Fast Instructions': '1. Remove sleeve and peel corner of film to vent\n2. Remove sauce container\n3. Microwave for 2-4 mins or until heated thoroughly\n4. Pour sauce on top\n5. Remove film',
                    'Color': 'Green'
                },
                {
                    'Season': 'Fall 2024',
                    'Rotation': 'Week 1',
                    'Dish Name': 'Chicken Marsala',
                    'Dish Subtitle': 'with Wild Mushrooms',
                    'Net Weight': '1.5 lbs',
                    'Ingredients': 'Free-range chicken breast, marsala wine, wild mushrooms, shallots, garlic, butter, olive oil, salt, pepper',
                    'Allergens': 'None',
                    'Chef Instructions': '1. Preheat oven to 375°F\n2. Remove packaging\n3. Place in oven-safe dish\n4. Bake 20-25 minutes\n5. Let rest 5 minutes',
                    'Fast Instructions': '1. Remove packaging\n2. Microwave on high 3-4 minutes\n3. Let stand 2 minutes\n4. Stir and serve',
                    'Color': 'Orange'
                }
            ];
            populateSeasonDropdown();
            console.log('Sample data loaded:', allDishes.length, 'dishes');
        }
        
        // Parse CSV text into dish objects
        function parseCSV(csvText) {
            // First, we need to properly handle CSV with newlines inside quoted fields
            // Split by lines but be careful about quoted fields that span multiple lines
            const lines = [];
            let currentLine = '';
            let inQuotes = false;
            
            for (let i = 0; i < csvText.length; i++) {
                const char = csvText[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === '\n' && !inQuotes) {
                    if (currentLine.trim()) {
                        lines.push(currentLine.trim());
                    }
                    currentLine = '';
                    continue;
                }
                
                currentLine += char;
            }
            
            // Add the last line if it exists
            if (currentLine.trim()) {
                lines.push(currentLine.trim());
            }
            
            console.log('Total lines after proper parsing:', lines.length);
            console.log('First few lines:', lines.slice(0, 3));
            
            if (lines.length < 2) return [];
            
            // Parse CSV with proper handling of quoted fields
            const parseCSVLine = (line) => {
                const result = [];
                let current = '';
                let inQuotes = false;
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        result.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                result.push(current.trim());
                return result;
            };
            
            const headers = parseCSVLine(lines[0]).map(h => h.replace(/^"/, '').replace(/"$/, ''));
            console.log('Headers:', headers);
            
            const dishes = [];
            
            for (let i = 1; i < lines.length; i++) {
                const values = parseCSVLine(lines[i]).map(v => v.replace(/^"/, '').replace(/"$/, ''));
                console.log(`Row ${i} values:`, values);
                
                if (values.length >= headers.length) {
                    const dish = {};
                    headers.forEach((header, index) => {
                        dish[header] = values[index] || '';
                    });
                    console.log('Parsed dish:', dish);
                    dishes.push(dish);
                } else {
                    console.log(`Row ${i} has insufficient columns: ${values.length} vs ${headers.length}`);
                }
            }
            
            console.log('Final dishes array:', dishes);
            return dishes;
        }
        
        // Populate season dropdown with unique seasons
        function populateSeasonDropdown() {
            const seasonSelect = document.getElementById('seasonSelect');
            const seasons = [...new Set(allDishes.map(dish => dish.Season).filter(Boolean))];
            
            seasonSelect.innerHTML = '<option value="">Select Season</option>';
            seasons.forEach(season => {
                const option = document.createElement('option');
                option.value = season;
                option.textContent = season;
                seasonSelect.appendChild(option);
            });
        }
        
        // Populate rotation dropdown based on selected season
        function populateRotationDropdown(season) {
            const rotationSelect = document.getElementById('rotationSelect');
            const rotations = [...new Set(allDishes
                .filter(dish => dish.Season === season)
                .map(dish => dish.Rotation)
                .filter(Boolean))];
            
            rotationSelect.innerHTML = '<option value="">Select Rotation</option>';
            rotations.forEach(rotation => {
                const option = document.createElement('option');
                option.value = rotation;
                option.textContent = rotation;
                rotationSelect.appendChild(option);
            });
            
            rotationSelect.disabled = !season;
        }
        
        // Filter dishes by season and rotation
        function filterDishesBySeasonRotation(season, rotation) {
            return allDishes.filter(dish => 
                dish.Season === season && dish.Rotation === rotation
            );
        }
        
        // Load labels for selected season and rotation
        function loadLabels() {
            const season = document.getElementById('seasonSelect').value;
            const rotation = document.getElementById('rotationSelect').value;
            
            if (!season || !rotation) {
                alert('Please select both Season and Rotation');
                return;
            }
            
            filteredDishes = filterDishesBySeasonRotation(season, rotation);
            
            if (filteredDishes.length === 0) {
                alert('No dishes found for the selected Season and Rotation');
                return;
            }
            
            currentLabelIndex = 0;
            updateLabelDisplay();
            updateNavigationButtons();
            document.getElementById('downloadAllBtn').disabled = false;
            document.getElementById('downloadSingleBtn').disabled = false;
            
            // Show label and hide loading indicator
            showLabel();
        }
        
        // Show label and hide loading indicator
        function showLabel() {
            document.getElementById('loadingIndicator').style.display = 'none';
            document.getElementById('labelPreview').style.display = 'grid';
        }
        
        // Show loading indicator and hide label
        function showLoading() {
            document.getElementById('loadingIndicator').style.display = 'flex';
            document.getElementById('labelPreview').style.display = 'none';
        }
        
        // Update label display with current dish data
        function updateLabelDisplay() {
            if (filteredDishes.length === 0) return;
            
            const dish = filteredDishes[currentLabelIndex];
            const bestByDate = document.getElementById('bestBy').value;
            
            console.log('Updating label display for dish:', dish);
            
            // Update preview elements
            document.getElementById('previewDish').textContent = dish['Dish Name'] || 'Unknown Dish';
            document.getElementById('previewSubtitle').textContent = dish['Dish Subtitle'] || '';
            document.getElementById('previewWeight').textContent = dish['Net Wt'] || dish['Net Weight'] || '-';
            document.getElementById('previewBestBy').textContent = formatDateWithDay(bestByDate);
            document.getElementById('previewIngredients').textContent = dish.Ingredients || '-';
            document.getElementById('previewAllergens').textContent = dish.Allergens || 'None';
            document.getElementById('previewChefInstructions').innerHTML = formatInstructions(dish['Chef Instructions'] || '-');
            document.getElementById('previewFastInstructions').innerHTML = formatInstructions(dish['Fast Instructions'] || '-');
            
            // Update brand color from CSV Color column
            if (dish.Color) {
                const colorMapping = {
                    'Green': 'green',
                    'Red': 'red', 
                    'Blue': 'blue',
                    'Orange': 'orange',
                    'Gray': 'gray'
                };
                const mappedColor = colorMapping[dish.Color] || 'green';
                // Color selector removed, using default green branding
            }
            
            applyBranding();
            fitTitleToRow();
            updateLabelCounter();
        }
        
        // Update label counter display
        function updateLabelCounter() {
            const counter = document.getElementById('labelCounter');
            counter.textContent = `Label ${currentLabelIndex + 1} of ${filteredDishes.length}`;
        }
        
        // Navigation functions
        function previousLabel() {
            if (currentLabelIndex > 0) {
                currentLabelIndex--;
                updateLabelDisplay();
                updateNavigationButtons();
            }
        }
        
        function nextLabel() {
            if (currentLabelIndex < filteredDishes.length - 1) {
                currentLabelIndex++;
                updateLabelDisplay();
                updateNavigationButtons();
            }
        }
        
        // Update navigation button states
        function updateNavigationButtons() {
            document.getElementById('prevLabel').disabled = currentLabelIndex === 0;
            document.getElementById('nextLabel').disabled = currentLabelIndex === filteredDishes.length - 1;
        }
        
        // Calculate Best By Date: Tuesday 5 days after next Friday
        function calculateBestByDate() {
            const today = new Date();
            const dayOfWeek = today.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
            
            // Find next Friday
            let daysUntilFriday;
            if (dayOfWeek <= 5) { // Sunday (0) to Friday (5)
                daysUntilFriday = 5 - dayOfWeek;
            } else { // Saturday (6)
                daysUntilFriday = 6; // Next Friday is 6 days away
            }
            
            const nextFriday = new Date(today);
            nextFriday.setDate(today.getDate() + daysUntilFriday);
            
            // Add 5 days to get Tuesday
            const bestByDate = new Date(nextFriday);
            bestByDate.setDate(nextFriday.getDate() + 5);
            
            return bestByDate.toISOString().split('T')[0];
        }
        
        function formatDateWithDay(dateString) {
            if (!dateString) return 'Thu, 10/20/2025';
            const date = new Date(dateString);
            const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            const dayName = days[date.getDay()];
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const year = date.getFullYear();
            return `${dayName}, ${month}/${day}/${year}`;
        }
        
        function formatInstructions(text) {
            const lines = text.split('\n').filter(line => line.trim());
            const listItems = lines.map(line => {
                // Remove numbering if present and clean up
                return '<li>' + line.replace(/^\d+\.\s*/, '') + '</li>';
            }).join('');
            return '<ol>' + listItems + '</ol>';
        }
        
        // Batch PDF generation with ZIP packaging
        async function downloadAllPDFs() {
            if (filteredDishes.length === 0) {
                alert('No dishes loaded. Please select Season and Rotation first.');
                return;
            }
            
            const bestByDate = document.getElementById('bestBy').value;
            if (!bestByDate) {
                alert('Please enter a Best By Date');
                return;
            }
            
            try {
                const zip = new JSZip();
                const season = document.getElementById('seasonSelect').value;
                const rotation = document.getElementById('rotationSelect').value;
                
                // Show loading message
                const downloadBtn = document.getElementById('downloadAllBtn');
                const originalText = downloadBtn.textContent;
                downloadBtn.textContent = 'Generating PDFs...';
                downloadBtn.disabled = true;
                
                // Generate PDF for each dish
                for (let i = 0; i < filteredDishes.length; i++) {
                    const dish = filteredDishes[i];
                    const pdfBlob = await createPDFForDish(dish, bestByDate);
                    
                    // Create filename
                    const dishName = dish['Dish Name'].replace(/[^a-zA-Z0-9]/g, '_');
                    const filename = `${season}_${rotation}_${dishName}.pdf`;
                    
                    zip.file(filename, pdfBlob);
                }
                
                // Generate ZIP file
                const zipBlob = await zip.generateAsync({type: 'blob'});
                
                // Download ZIP
                const zipFilename = `${season}_${rotation}_labels_${new Date().toISOString().split('T')[0]}.zip`;
                downloadZip(zipBlob, zipFilename);
                
                // Reset button
                downloadBtn.textContent = originalText;
                downloadBtn.disabled = false;
                
            } catch (error) {
                console.error('Error generating PDFs:', error);
                alert('Error generating PDFs. Please try again.');
                
                // Reset button
                const downloadBtn = document.getElementById('downloadAllBtn');
                downloadBtn.textContent = 'Download All PDFs';
                downloadBtn.disabled = false;
            }
        }
        
        // Create PDF for a single dish
        async function createPDFForDish(dishData, bestByDate) {
            // Temporarily update the preview with this dish's data
            const originalIndex = currentLabelIndex;
            const originalDish = filteredDishes[currentLabelIndex];
            
            // Update preview to current dish
            filteredDishes[currentLabelIndex] = dishData;
            updateLabelDisplay();
            
            // Ensure text fitting is applied and synchronized before PDF generation
            await new Promise(resolve => {
                requestAnimationFrame(() => {
                    fitTitleToRow();
                    // Wait for text fitting to complete
                    setTimeout(async () => {
                        // Ensure PDF uses exact same font sizes as preview
                        await FontSyncManager.ensurePDFSync();
                        
                        // Validate synchronization
                        if (!FontSyncManager.validateSync()) {
                            console.error('FontSyncManager: PDF generation may not match preview!');
                            throw new Error('PDF-Preview sync validation failed. PDF generation aborted.');
                        }
                        
                        // Additional visual validation
                        const visualSync = await VisualValidator.validatePDFPreviewSync();
                        if (!visualSync) {
                            console.error('VisualValidator: PDF-Preview visual sync failed!');
                            throw new Error('Visual sync validation failed. PDF generation aborted.');
                        }
                        
                        resolve();
                    }, 100);
                });
            });
            
            const { jsPDF } = window.jspdf;
            const label = document.getElementById('labelPreview');
            
            // Generate canvas from HTML normally (no bleed capture)
            const canvas = await html2canvas(label, {
                scale: 3, // Higher scale for better quality
                useCORS: true,
                logging: false,
                backgroundColor: '#ffffff'
            });
            
            // Create PDF with bleed area (trim + bleed on all sides)
            const bleed = 0.125; // 1/8" bleed
            const pdf = new jsPDF({
                orientation: 'landscape',
                unit: 'in',
                format: [3 + (bleed * 2), 4 + (bleed * 2)] // Add bleed to both dimensions
            });
            
            const imgData = canvas.toDataURL('image/png');
            
            // Position image in center of PDF (with bleed margins)
            // This creates a clean white bleed area, which is professional and common
            pdf.addImage(imgData, 'PNG', bleed, bleed, 4, 3);
            
            // Restore original state
            filteredDishes[currentLabelIndex] = originalDish;
            currentLabelIndex = originalIndex;
            updateLabelDisplay();
            
            return pdf.output('blob');
        }
        
        // Add crop marks to PDF
        function addCropMarks(pdf, bleed) {
            const cropMarkLength = 0.125; // 1/8 inch
            const cropMarkThickness = 0.005; // Very thin lines
            
            // Set line width and color
            pdf.setLineWidth(cropMarkThickness);
            pdf.setDrawColor(150, 150, 150); // Light gray color
            
            // Top-left crop mark
            pdf.line(bleed - cropMarkLength, bleed, bleed + cropMarkLength, bleed);
            pdf.line(bleed, bleed - cropMarkLength, bleed, bleed + cropMarkLength);
            
            // Top-right crop mark
            pdf.line(4 + bleed - cropMarkLength, bleed, 4 + bleed + cropMarkLength, bleed);
            pdf.line(4 + bleed, bleed - cropMarkLength, 4 + bleed, bleed + cropMarkLength);
            
            // Bottom-left crop mark
            pdf.line(bleed - cropMarkLength, 3 + bleed, bleed + cropMarkLength, 3 + bleed);
            pdf.line(bleed, 3 + bleed - cropMarkLength, bleed, 3 + bleed + cropMarkLength);
            
            // Bottom-right crop mark
            pdf.line(4 + bleed - cropMarkLength, 3 + bleed, 4 + bleed + cropMarkLength, 3 + bleed);
            pdf.line(4 + bleed, 3 + bleed - cropMarkLength, 4 + bleed, 3 + bleed + cropMarkLength);
        }
        
        // Download ZIP file
        function downloadZip(zipBlob, filename) {
            const url = URL.createObjectURL(zipBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function printLabel() {
            window.print();
        }
        
        async function generatePDF() {
            if (filteredDishes.length === 0) {
                alert('No dishes loaded. Please select Season and Rotation first.');
                return;
            }
            
            const bestByDate = document.getElementById('bestBy').value;
            if (!bestByDate) {
                alert('Please enter a Best By Date');
                return;
            }
            
            const dish = filteredDishes[currentLabelIndex];
            const pdfBlob = await createPDFForDish(dish, bestByDate);
            
            // Create filename
            const season = document.getElementById('seasonSelect').value;
            const rotation = document.getElementById('rotationSelect').value;
            const dishName = dish['Dish Name'].replace(/[^a-zA-Z0-9]/g, '_');
            const filename = `${season}_${rotation}_${dishName}.pdf`;
            
            // Download single PDF
            const url = URL.createObjectURL(pdfBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // Initialize with today's dates and load sheet data
        window.onload = async function() {
            console.log('Starting initialization...');
            
            // Show loading indicator initially
            showLoading();
            
            // Set Best By Date to Tuesday 5 days after next Friday
            document.getElementById('bestBy').value = calculateBestByDate();
            
            // Load dish data from Google Sheets
            console.log('Loading dish data...');
            await fetchDishesFromSheet();
            
            console.log('All dishes loaded:', allDishes.length);
            
            // Auto-load first season and rotation if available
            if (allDishes.length > 0) {
                console.log('Auto-loading first season and rotation...');
                const seasons = [...new Set(allDishes.map(dish => dish.Season).filter(Boolean))];
                console.log('Available seasons:', seasons);
                
                if (seasons.length > 0) {
                    const firstSeason = seasons[0];
                    console.log('Selecting first season:', firstSeason);
                    document.getElementById('seasonSelect').value = firstSeason;
                    populateRotationDropdown(firstSeason);
                    
                    const rotations = [...new Set(allDishes
                        .filter(dish => dish.Season === firstSeason)
                        .map(dish => dish.Rotation)
                        .filter(Boolean))];
                    
                    console.log('Available rotations for', firstSeason, ':', rotations);
                    
                    if (rotations.length > 0) {
                        const firstRotation = rotations[0];
                        console.log('Selecting first rotation:', firstRotation);
                        document.getElementById('rotationSelect').value = firstRotation;
                        
                        // Auto-load the labels
                        console.log('Auto-loading labels...');
                        loadLabels();
                    }
                }
            } else {
                console.log('No dishes available to load');
                // Keep loading indicator visible if no data
            }
            
            // Initialize scaling after content exists
            initializePreviewScaling();
            
            // Season change handler
            const seasonSelect = document.getElementById('seasonSelect');
            seasonSelect.addEventListener('change', (e) => {
                populateRotationDropdown(e.target.value);
                // Auto-load labels if rotation is already selected
                const rotation = document.getElementById('rotationSelect').value;
                if (rotation) {
                    loadLabels();
                }
            });
            
            // Rotation change handler
            const rotationSelect = document.getElementById('rotationSelect');
            rotationSelect.addEventListener('change', (e) => {
                const season = document.getElementById('seasonSelect').value;
                if (season && e.target.value) {
                    loadLabels();
                }
            });
            
            // Best By date change handler
            const bestByInput = document.getElementById('bestBy');
            bestByInput.addEventListener('change', () => {
                if (filteredDishes.length > 0) {
                    updateLabelDisplay();
                }
            });
            
            // Grid toggle handler
            const gridToggle = document.getElementById('toggleGridLines');
            const label = document.getElementById('labelPreview');
            if (gridToggle && label) {
                gridToggle.addEventListener('change', () => {
                    if (gridToggle.checked) {
                        label.classList.add('show-grid');
                    } else {
                        label.classList.remove('show-grid');
                    }
                });
            }
            
            // Initial branding
            applyBranding();
            
            // Ensure text fitting runs after everything is loaded
            setTimeout(() => {
                fitTitleToRow();
                console.log('Initial text fitting applied');
            }, 500);
        };

        // Branding application based on color selection
        function applyBranding() {
            // Get color from current dish data
            const dish = filteredDishes[currentLabelIndex];
            const chosen = dish && dish.Color ? dish.Color.toLowerCase() : 'green';
            const labelEl = document.querySelector('.label');
            const rowEl = document.querySelector('.cell-1');
            const logoImg = document.getElementById('brandLogo');
            const brandTitle = document.querySelector('.brand-title');
            const useMap = {
                green: 'var(--color-green)',
                orange: 'var(--color-orange)',
                gray: 'var(--color-gray)',
                red: 'var(--color-red)',
                blue: 'var(--color-blue)'
            };
            const bg = useMap[chosen] || useMap.green;
            if (rowEl) {
                rowEl.style.setProperty('--brand-bg', bg);
            }
            // Logo and text color switching
            const isGray = chosen === 'gray';
            const whiteLogo = 'images/logos/White Logo Suite/HMC_Vertical Full Lockup_White [RGB].png';
            const blackLogo = 'images/logos/Black Logo Suite/HMC_Vertical Full Lockup_Black [RGB].png';
            if (logoImg) logoImg.src = isGray ? blackLogo : whiteLogo;
            if (brandTitle) {
                brandTitle.style.color = isGray ? '#000' : '#fff';
            }
        }

        // Enhanced text fitting with better scaling algorithm
        function fitTitleToRow() {
            const rowEl = document.querySelector('.cell-1');
            const logoImg = document.getElementById('brandLogo');
            const titleEl = document.getElementById('previewDish');
            const subtitleEl = document.getElementById('previewSubtitle');
            
            // Future-proof validation: ensure all required elements exist
            if (!rowEl || !logoImg || !titleEl || !subtitleEl) {
                console.error('fitTitleToRow: Required elements not found. Sync may be broken.');
                return;
            }
            
            // Future-proof validation: ensure FontSyncManager is available
            if (typeof FontSyncManager === 'undefined') {
                console.error('fitTitleToRow: FontSyncManager not available. Sync will be broken.');
                return;
            }
            
            // Reset to CSS defaults first
            titleEl.style.fontSize = '';
            subtitleEl.style.fontSize = '';
            
            // Wait for CSS to apply, then measure
            requestAnimationFrame(() => {
                // Get available space - be more generous with space calculations
                const logoHeight = logoImg.getBoundingClientRect().height;
                const containerHeight = rowEl.getBoundingClientRect().height;
                const availableHeight = Math.min(logoHeight, containerHeight) - 4; // reduced padding
                
                const titleContainer = titleEl.parentElement;
                const availableWidth = titleContainer.getBoundingClientRect().width - 2; // minimal padding
                
                // Start with larger optimal sizes (25% larger than current)
                let titleSize = 32.5; // pt - increased by 25% from 26pt
                let subtitleSize = 22.75; // pt - increased by 25% from 18.2pt
                
                // Debug: log all space measurements
                console.log('=== SPACE DEBUGGING ===');
                console.log('Logo element:', logoImg);
                console.log('Row element:', rowEl);
                console.log('Title container:', titleContainer);
                console.log('Title element:', titleEl);
                console.log('Subtitle element:', subtitleEl);
                
                console.log('Measurements:', {
                    logoHeight: logoHeight,
                    containerHeight: containerHeight,
                    availableHeight: availableHeight,
                    titleContainerWidth: titleContainer.getBoundingClientRect().width,
                    availableWidth: availableWidth,
                    titleElementWidth: titleEl.getBoundingClientRect().width,
                    subtitleElementWidth: subtitleEl.getBoundingClientRect().width
                });
                
                console.log('Element styles:', {
                    titleDisplay: window.getComputedStyle(titleEl).display,
                    titleWidth: window.getComputedStyle(titleEl).width,
                    titleMaxWidth: window.getComputedStyle(titleEl).maxWidth,
                    subtitleDisplay: window.getComputedStyle(subtitleEl).display,
                    subtitleWidth: window.getComputedStyle(subtitleEl).width,
                    subtitleMaxWidth: window.getComputedStyle(subtitleEl).maxWidth
                });
                
                // Function to check if individual text fits horizontally
                const checkTitleFits = (size) => {
                    titleEl.style.fontSize = size + 'pt';
                    titleEl.offsetHeight; // Force reflow
                    return titleEl.scrollWidth <= availableWidth;
                };
                
                const checkSubtitleFits = (size) => {
                    subtitleEl.style.fontSize = size + 'pt';
                    subtitleEl.offsetHeight; // Force reflow
                    return subtitleEl.scrollWidth <= availableWidth;
                };
                
                // Function to check if text fits vertically
                const checkVerticalFit = () => {
                    const titleHeight = titleEl.getBoundingClientRect().height;
                    const subtitleHeight = subtitleEl.getBoundingClientRect().height;
                    const totalHeight = titleHeight + subtitleHeight;
                    const fits = totalHeight <= availableHeight;
                    
                    console.log(`Vertical fit check (${titleSize}pt/${subtitleSize}pt):`, {
                        titleHeight,
                        subtitleHeight,
                        totalHeight,
                        availableHeight,
                        fits
                    });
                    
                    return fits;
                };
                
                // Scale each element independently
                const scaleElement = (startSize, checkFunction, minSize, elementName) => {
                    let currentSize = startSize;
                    let iterations = 0;
                    const maxIterations = 50;
                    
                    while (iterations < maxIterations) {
                        if (checkFunction(currentSize)) {
                            console.log(`${elementName} fits at ${currentSize.toFixed(1)}pt`);
                            break;
                        }
                        
                        currentSize *= 0.90; // Scale down by 10% per iteration (faster scaling)
                        currentSize = Math.max(minSize, currentSize);
                        
                        if (Math.abs(currentSize - minSize) < 0.1) {
                            console.log(`${elementName} reached minimum size ${minSize}pt`);
                            break;
                        }
                        
                        iterations++;
                    }
                    
                    return currentSize;
                };
                
                // Scale title independently
                const finalTitleSize = scaleElement(titleSize, checkTitleFits, 22.5, 'Title');
                
                // Scale subtitle independently  
                const finalSubtitleSize = scaleElement(subtitleSize, checkSubtitleFits, 17.5, 'Subtitle');
                
                // Apply the independently scaled sizes
                titleEl.style.fontSize = finalTitleSize + 'pt';
                subtitleEl.style.fontSize = finalSubtitleSize + 'pt';
                
                // Check if both fit vertically after independent scaling
                const totalHeight = titleEl.getBoundingClientRect().height + subtitleEl.getBoundingClientRect().height;
                if (totalHeight > availableHeight) {
                    console.log('Vertical constraint: scaling both down proportionally');
                    const scaleFactor = availableHeight / totalHeight;
                    const scaledTitleSize = Math.max(20, finalTitleSize * scaleFactor);
                    const scaledSubtitleSize = Math.max(15, finalSubtitleSize * scaleFactor);
                    
                    titleEl.style.fontSize = scaledTitleSize + 'pt';
                    subtitleEl.style.fontSize = scaledSubtitleSize + 'pt';
                    
                    titleSize = scaledTitleSize;
                    subtitleSize = scaledSubtitleSize;
                } else {
                    titleSize = finalTitleSize;
                    subtitleSize = finalSubtitleSize;
                }
                
                // Apply final sizes using the sync manager
                FontSyncManager.applyFontSizes(titleSize, subtitleSize);
                
                console.log(`Text fitting complete: Title=${titleSize.toFixed(1)}pt, Subtitle=${subtitleSize.toFixed(1)}pt`);
            });
        }

        // Visual validation system for PDF-preview sync
        const VisualValidator = {
            // Take a screenshot of the preview for comparison
            capturePreviewSnapshot() {
                const label = document.getElementById('labelPreview');
                if (!label) return null;
                
                return new Promise((resolve) => {
                    html2canvas(label, {
                        scale: 1,
                        useCORS: true,
                        logging: false,
                        backgroundColor: '#ffffff'
                    }).then(canvas => {
                        resolve(canvas.toDataURL());
                    }).catch(() => resolve(null));
                });
            },
            
            // Validate that preview and PDF would be identical
            async validatePDFPreviewSync() {
                const snapshot = await this.capturePreviewSnapshot();
                if (!snapshot) return false;
                
                // Store snapshot for debugging
                this.lastSnapshot = snapshot;
                
                // Check if font sizes are properly synchronized
                const isSynced = FontSyncManager.validateSync();
                
                if (!isSynced) {
                    console.warn('VisualValidator: Preview-PDF sync validation failed');
                    return false;
                }
                
                console.log('VisualValidator: Preview-PDF sync validated successfully');
                return true;
            }
        };

        // Preview scaling logic (on-screen only)
        function initializePreviewScaling() {
            // Set up resize observer for dynamic text scaling
            if (window.ResizeObserver) {
                const resizeObserver = new ResizeObserver(() => {
                    // Debounce the text fitting to avoid excessive calls
                    clearTimeout(window.textFitTimeout);
                    window.textFitTimeout = setTimeout(() => {
                        fitTitleToRow();
                        // Validate sync after text fitting
                        VisualValidator.validatePDFPreviewSync();
                    }, 100);
                });
                
                const labelPreview = document.getElementById('labelPreview');
                if (labelPreview) {
                    resizeObserver.observe(labelPreview);
                }
            }
        }
    </script>
</body>
</html>